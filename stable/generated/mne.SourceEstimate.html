<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mne.SourceEstimate &mdash; MNE 0.12.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootswatch-3.3.4/flatly/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.12.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.4/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="MNE 0.12.0 documentation" href="../index.html" />
    <link rel="up" title="Python API Reference" href="../python_reference.html" />
    <link rel="next" title="mne.VolSourceEstimate" href="mne.VolSourceEstimate.html" />
    <link rel="prev" title="mne.SourceSpaces" href="mne.SourceSpaces.html" />

<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,400,700' rel='stylesheet' type='text/css'>


    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37225609-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>



    <script type="text/javascript">
    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);
    js.id=id;js.src="http://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
    </script>



    <script type="text/javascript">
    (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    </script>


  </head>
  <body>





  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><img src="../_static/mne_logo_small.png">
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.12.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../getting_started.html">Get started</a></li>
                <li><a href="../tutorials.html">Tutorials</a></li>
                <li><a href="../auto_examples/index.html">Gallery</a></li>
                <li><a href="../python_reference.html">API</a></li>
                <li><a href="../manual/index.html">Manual</a></li>
                <li><a href="../faq.html">FAQ</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contribute to MNE</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../python_reference.html">Python API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../manual/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whats_new.html">What&#8217;s new</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cite.html">How to cite MNE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">Related publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cited.html">Publications from MNE users</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">mne.SourceEstimate</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/mne_logo_small.png" alt="Logo"/>
            </a></p><ul>
<li><a class="reference internal" href="#">mne.SourceEstimate</a></li>
</ul>

  <li>
    <a href="mne.SourceSpaces.html" title="Previous Chapter: mne.SourceSpaces"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; mne.SourceSpaces</span>
    </a>
  </li>
  <li>
    <a href="mne.VolSourceEstimate.html" title="Next Chapter: mne.VolSourceEstimate"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">mne.VolSource... &raquo;</span>
    </a>
  </li>
<form action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="col-md-12">
      
  <div class="section" id="mne-sourceestimate">
<h1>mne.SourceEstimate<a class="headerlink" href="#mne-sourceestimate" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="mne.SourceEstimate">
<em class="property">class </em><tt class="descclassname">mne.</tt><tt class="descname">SourceEstimate</tt><big>(</big><em>data</em>, <em>vertices=None</em>, <em>tmin=None</em>, <em>tstep=None</em>, <em>subject=None</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.SourceEstimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for surface source estimates</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array of shape (n_dipoles, n_times) | 2-tuple (kernel, sens_data)</p>
<blockquote>
<div><p>The data in source space. The data can either be a single array or
a tuple with two arrays: &#8220;kernel&#8221; shape (n_vertices, n_sensors) and
&#8220;sens_data&#8221; shape (n_sensors, n_times). In this case, the source
space data corresponds to &#8220;numpy.dot(kernel, sens_data)&#8221;.</p>
</div></blockquote>
<p><strong>vertices</strong> : list of two arrays</p>
<blockquote>
<div><p>Vertex numbers corresponding to the data.</p>
</div></blockquote>
<p><strong>tmin</strong> : scalar</p>
<blockquote>
<div><p>Time point of the first sample in data.</p>
</div></blockquote>
<p><strong>tstep</strong> : scalar</p>
<blockquote>
<div><p>Time step between successive samples in data.</p>
</div></blockquote>
<p><strong>subject</strong> : str | None</p>
<blockquote>
<div><p>The subject name. While not necessary, it is safer to set the
subject parameter to avoid analysis errors.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><p class="first"><strong>subject</strong> : str | None</p>
<blockquote>
<div><p>The subject name.</p>
</div></blockquote>
<p><strong>times</strong> : array of shape (n_times,)</p>
<blockquote>
<div><p>The time vector.</p>
</div></blockquote>
<p><strong>vertices</strong> : list of two arrays of shape (n_dipoles,)</p>
<blockquote>
<div><p>The indices of the dipoles in the left and right source space.</p>
</div></blockquote>
<p><strong>data</strong> : array of shape (n_dipoles, n_times)</p>
<blockquote>
<div><p>The data in source space.</p>
</div></blockquote>
<p><strong>shape</strong> : tuple</p>
<blockquote class="last">
<div><p>The shape of the data. A tuple of int (n_dipoles, n_times).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mne.SourceEstimate.bin" title="mne.SourceEstimate.bin"><tt class="xref py py-obj docutils literal"><span class="pre">bin</span></tt></a>(width[,&nbsp;tstart,&nbsp;tstop,&nbsp;func])</td>
<td>Returns a SourceEstimate object with data summarized over time bins</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.SourceEstimate.center_of_mass" title="mne.SourceEstimate.center_of_mass"><tt class="xref py py-obj docutils literal"><span class="pre">center_of_mass</span></tt></a>([subject,&nbsp;hemi,&nbsp;...])</td>
<td>Return the vertex on a given surface that is at the center of mass of  the activity in stc.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.SourceEstimate.copy" title="mne.SourceEstimate.copy"><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt></a>()</td>
<td>Return copy of SourceEstimate instance</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.SourceEstimate.crop" title="mne.SourceEstimate.crop"><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt></a>([tmin,&nbsp;tmax])</td>
<td>Restrict SourceEstimate to a time interval</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.SourceEstimate.expand" title="mne.SourceEstimate.expand"><tt class="xref py py-obj docutils literal"><span class="pre">expand</span></tt></a>(vertices)</td>
<td>Expand SourceEstimate to include more vertices</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.SourceEstimate.extract_label_time_course" title="mne.SourceEstimate.extract_label_time_course"><tt class="xref py py-obj docutils literal"><span class="pre">extract_label_time_course</span></tt></a>(labels,&nbsp;src[,&nbsp;...])</td>
<td>Extract label time courses for lists of labels</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.SourceEstimate.get_peak" title="mne.SourceEstimate.get_peak"><tt class="xref py py-obj docutils literal"><span class="pre">get_peak</span></tt></a>([hemi,&nbsp;tmin,&nbsp;tmax,&nbsp;mode,&nbsp;...])</td>
<td>Get location and latency of peak amplitude</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.SourceEstimate.in_label" title="mne.SourceEstimate.in_label"><tt class="xref py py-obj docutils literal"><span class="pre">in_label</span></tt></a>(label)</td>
<td>Returns a SourceEstimate object restricted to a label</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.SourceEstimate.mean" title="mne.SourceEstimate.mean"><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt></a>()</td>
<td>Make a summary stc file with mean power between tmin and tmax.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.SourceEstimate.morph" title="mne.SourceEstimate.morph"><tt class="xref py py-obj docutils literal"><span class="pre">morph</span></tt></a>(subject_to[,&nbsp;grade,&nbsp;smooth,&nbsp;...])</td>
<td>Morph a source estimate from one subject to another</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.SourceEstimate.morph_precomputed" title="mne.SourceEstimate.morph_precomputed"><tt class="xref py py-obj docutils literal"><span class="pre">morph_precomputed</span></tt></a>(subject_to,&nbsp;vertices_to,&nbsp;...)</td>
<td>Morph source estimate between subjects using a precomputed matrix</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.SourceEstimate.plot" title="mne.SourceEstimate.plot"><tt class="xref py py-obj docutils literal"><span class="pre">plot</span></tt></a>([subject,&nbsp;surface,&nbsp;hemi,&nbsp;colormap,&nbsp;...])</td>
<td>Plot SourceEstimates with PySurfer</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.SourceEstimate.resample" title="mne.SourceEstimate.resample"><tt class="xref py py-obj docutils literal"><span class="pre">resample</span></tt></a>(sfreq[,&nbsp;npad,&nbsp;window,&nbsp;n_jobs,&nbsp;verbose])</td>
<td>Resample data</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.SourceEstimate.save" title="mne.SourceEstimate.save"><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt></a>(fname[,&nbsp;ftype,&nbsp;verbose])</td>
<td>Save the source estimates to a file</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.SourceEstimate.sqrt" title="mne.SourceEstimate.sqrt"><tt class="xref py py-obj docutils literal"><span class="pre">sqrt</span></tt></a>()</td>
<td>Take the square root</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.SourceEstimate.time_as_index" title="mne.SourceEstimate.time_as_index"><tt class="xref py py-obj docutils literal"><span class="pre">time_as_index</span></tt></a>(times[,&nbsp;use_rounding])</td>
<td>Convert time to indices</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.SourceEstimate.to_data_frame" title="mne.SourceEstimate.to_data_frame"><tt class="xref py py-obj docutils literal"><span class="pre">to_data_frame</span></tt></a>([picks,&nbsp;index,&nbsp;scale_time,&nbsp;...])</td>
<td>Export data in tabular structure as a pandas DataFrame.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.SourceEstimate.to_original_src" title="mne.SourceEstimate.to_original_src"><tt class="xref py py-obj docutils literal"><span class="pre">to_original_src</span></tt></a>(src_orig[,&nbsp;subject_orig,&nbsp;...])</td>
<td>Return a SourceEstimate from morphed source to the original subject</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.SourceEstimate.transform" title="mne.SourceEstimate.transform"><tt class="xref py py-obj docutils literal"><span class="pre">transform</span></tt></a>(func[,&nbsp;idx,&nbsp;tmin,&nbsp;tmax,&nbsp;copy])</td>
<td>Apply linear transform</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.SourceEstimate.transform_data" title="mne.SourceEstimate.transform_data"><tt class="xref py py-obj docutils literal"><span class="pre">transform_data</span></tt></a>(func[,&nbsp;idx,&nbsp;tmin_idx,&nbsp;tmax_idx])</td>
<td>Get data after a linear (time) transform has been applied</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="mne.SourceEstimate.__init__">
<tt class="descname">__init__</tt><big>(</big><em>data</em>, <em>vertices=None</em>, <em>tmin=None</em>, <em>tstep=None</em>, <em>subject=None</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.SourceEstimate.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.bin">
<tt class="descname">bin</tt><big>(</big><em>width</em>, <em>tstart=None</em>, <em>tstop=None</em>, <em>func=&lt;function mean at 0x2aef3efaf230&gt;</em><big>)</big><a class="headerlink" href="#mne.SourceEstimate.bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a SourceEstimate object with data summarized over time bins</p>
<p>Time bins of <tt class="docutils literal"><span class="pre">width</span></tt> seconds. This method is intended for
visualization only. No filter is applied to the data before binning,
making the method inappropriate as a tool for downsampling data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>width</strong> : scalar</p>
<blockquote>
<div><p>Width of the individual bins in seconds.</p>
</div></blockquote>
<p><strong>tstart</strong> : scalar | None</p>
<blockquote>
<div><p>Time point where the first bin starts. The default is the first
time point of the stc.</p>
</div></blockquote>
<p><strong>tstop</strong> : scalar | None</p>
<blockquote>
<div><p>Last possible time point contained in a bin (if the last bin would
be shorter than width it is dropped). The default is the last time
point of the stc.</p>
</div></blockquote>
<p><strong>func</strong> : callable</p>
<blockquote>
<div><p>Function that is applied to summarize the data. Needs to accept a
numpy.array as first input and an <tt class="docutils literal"><span class="pre">axis</span></tt> keyword argument.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>stc</strong> : instance of SourceEstimate</p>
<blockquote class="last">
<div><p>The binned SourceEstimate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.center_of_mass">
<tt class="descname">center_of_mass</tt><big>(</big><em>subject=None</em>, <em>hemi=None</em>, <em>restrict_vertices=False</em>, <em>subjects_dir=None</em><big>)</big><a class="headerlink" href="#mne.SourceEstimate.center_of_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vertex on a given surface that is at the center of mass
of  the activity in stc. Note that all activity must occur in a single
hemisphere, otherwise an error is returned. The &#8220;mass&#8221; of each point in
space for computing the spatial center of mass is computed by summing
across time, and vice-versa for each point in time in computing the
temporal center of mass. This is useful for quantifying spatio-temporal
cluster locations, especially when combined with the function
mne.source_space.vertex_to_mni().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>subject</strong> : string | None</p>
<blockquote>
<div><p>The subject the stc is defined for.</p>
</div></blockquote>
<p><strong>hemi</strong> : int, or None</p>
<blockquote>
<div><p>Calculate the center of mass for the left (0) or right (1)
hemisphere. If None, one of the hemispheres must be all zeroes,
and the center of mass will be calculated for the other
hemisphere (useful for getting COM for clusters).</p>
</div></blockquote>
<p><strong>restrict_vertices</strong> : bool, or array of int</p>
<blockquote>
<div><p>If True, returned vertex will be one from stc. Otherwise, it could
be any vertex from surf. If an array of int, the returned vertex
will come from that array. For most accuruate estimates, do not
restrict vertices.</p>
</div></blockquote>
<p><strong>subjects_dir</strong> : str, or None</p>
<blockquote>
<div><p>Path to the SUBJECTS_DIR. If None, the path is obtained by using
the environment variable SUBJECTS_DIR.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>vertex</strong> : int</p>
<blockquote>
<div><p>Vertex of the spatial center of mass for the inferred hemisphere,
with each vertex weighted by the sum of the stc across time. For a
boolean stc, then, this would be weighted purely by the duration
each vertex was active.</p>
</div></blockquote>
<p><strong>hemi</strong> : int</p>
<blockquote>
<div><p>Hemisphere the vertex was taken from.</p>
</div></blockquote>
<p><strong>t</strong> : float</p>
<blockquote>
<div><p>Time of the temporal center of mass (weighted by the sum across
source vertices).</p>
</div></blockquote>
<p><strong>References:</strong> :</p>
<blockquote class="last">
<div><p>Used in Larson and Lee, &#8220;The cortical dynamics underlying effective
switching of auditory spatial attention&#8221;, NeuroImage 2012.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#mne.SourceEstimate.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return copy of SourceEstimate instance</p>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.crop">
<tt class="descname">crop</tt><big>(</big><em>tmin=None</em>, <em>tmax=None</em><big>)</big><a class="headerlink" href="#mne.SourceEstimate.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Restrict SourceEstimate to a time interval</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tmin</strong> : float | None</p>
<blockquote>
<div><p>The first time point in seconds. If None the first present is used.</p>
</div></blockquote>
<p><strong>tmax</strong> : float | None</p>
<blockquote class="last">
<div><p>The last time point in seconds. If None the last present is used.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mne.SourceEstimate.data">
<tt class="descname">data</tt><a class="headerlink" href="#mne.SourceEstimate.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Numpy array of source estimate data</p>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.expand">
<tt class="descname">expand</tt><big>(</big><em>vertices</em><big>)</big><a class="headerlink" href="#mne.SourceEstimate.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand SourceEstimate to include more vertices</p>
<p>This will add rows to stc.data (zero-filled) and modify stc.vertices
to include all vertices in stc.vertices and the input vertices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vertices</strong> : list of array</p>
<blockquote>
<div><p>New vertices to add. Can also contain old values.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>stc</strong> : instance of SourceEstimate</p>
<blockquote class="last">
<div><p>The modified stc (note: method operates inplace).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.extract_label_time_course">
<tt class="descname">extract_label_time_course</tt><big>(</big><em>labels</em>, <em>src</em>, <em>mode='mean_flip'</em>, <em>allow_empty=False</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.SourceEstimate.extract_label_time_course" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract label time courses for lists of labels</p>
<p>This function will extract one time course for each label. The way the
time courses are extracted depends on the mode parameter.</p>
<p>Valid values for mode are:</p>
<blockquote>
<div><ul class="simple">
<li>&#8216;mean&#8217;: Average within each label.</li>
<li>&#8216;mean_flip&#8217;: Average within each label with sign flip depending
on source orientation.</li>
<li>&#8216;pca_flip&#8217;: Apply an SVD to the time courses within each label
and use the scaled and sign-flipped first right-singular vector
as the label time course. The scaling is performed such that the
power of the label time course is the same as the average
per-vertex time course power within the label. The sign of the
resulting time course is adjusted by multiplying it with
&#8220;sign(dot(u, flip))&#8221; where u is the first left-singular vector,
and flip is a sing-flip vector based on the vertex normals. This
procedure assures that the phase does not randomly change by 180
degrees from one stc to the next.</li>
<li>&#8216;max&#8217;: Max value within each label.</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>labels</strong> : Label | list of Label</p>
<blockquote>
<div><p>The labels for which to extract the time courses.</p>
</div></blockquote>
<p><strong>src</strong> : list</p>
<blockquote>
<div><p>Source spaces for left and right hemisphere.</p>
</div></blockquote>
<p><strong>mode</strong> : str</p>
<blockquote>
<div><p>Extraction mode, see explanation above.</p>
</div></blockquote>
<p><strong>allow_empty</strong> : bool</p>
<blockquote>
<div><p>Instead of emitting an error, return all-zero time course for
labels that do not have any vertices in the source estimate.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>label_tc</strong> : array, shape=(len(labels), n_times)</p>
<blockquote class="last">
<div><p>Extracted time course for each label.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="mne.extract_label_time_course.html#mne.extract_label_time_course" title="mne.extract_label_time_course"><tt class="xref py py-obj docutils literal"><span class="pre">extract_label_time_course</span></tt></a></dt>
<dd>extract time courses for multiple STCs</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.get_peak">
<tt class="descname">get_peak</tt><big>(</big><em>hemi=None</em>, <em>tmin=None</em>, <em>tmax=None</em>, <em>mode='abs'</em>, <em>vert_as_index=False</em>, <em>time_as_index=False</em><big>)</big><a class="headerlink" href="#mne.SourceEstimate.get_peak" title="Permalink to this definition">¶</a></dt>
<dd><p>Get location and latency of peak amplitude</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>hemi</strong> : {&#8216;lh&#8217;, &#8216;rh&#8217;, None}</p>
<blockquote>
<div><p>The hemi to be considered. If None, the entire source space is
considered.</p>
</div></blockquote>
<p><strong>tmin</strong> : float | None</p>
<blockquote>
<div><p>The minimum point in time to be considered for peak getting.</p>
</div></blockquote>
<p><strong>tmax</strong> : float | None</p>
<blockquote>
<div><p>The maximum point in time to be considered for peak getting.</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8216;pos&#8217;, &#8216;neg&#8217;, &#8216;abs&#8217;}</p>
<blockquote>
<div><p>How to deal with the sign of the data. If &#8216;pos&#8217; only positive
values will be considered. If &#8216;neg&#8217; only negative values will
be considered. If &#8216;abs&#8217; absolute values will be considered.
Defaults to &#8216;abs&#8217;.</p>
</div></blockquote>
<p><strong>vert_as_index</strong> : bool</p>
<blockquote>
<div><p>whether to return the vertex index instead of of its ID.
Defaults to False.</p>
</div></blockquote>
<p><strong>time_as_index</strong> : bool</p>
<blockquote>
<div><p>Whether to return the time index instead of the latency.
Defaults to False.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>pos</strong> : int</p>
<blockquote>
<div><p>The vertex exhibiting the maximum response, either ID or index.</p>
</div></blockquote>
<p><strong>latency</strong> : float | int</p>
<blockquote class="last">
<div><p>The time point of the maximum response, either latency in seconds
or index.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.in_label">
<tt class="descname">in_label</tt><big>(</big><em>label</em><big>)</big><a class="headerlink" href="#mne.SourceEstimate.in_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a SourceEstimate object restricted to a label</p>
<p>SourceEstimate contains the time course of
activation of all sources inside the label.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>label</strong> : Label | BiHemiLabel</p>
<blockquote class="last">
<div><p>The label (as created for example by mne.read_label). If the label
does not match any sources in the SourceEstimate, a ValueError is
raised.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.mean">
<tt class="descname">mean</tt><big>(</big><big>)</big><a class="headerlink" href="#mne.SourceEstimate.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a summary stc file with mean power between tmin and tmax.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>stc</strong> : instance of SourceEstimate</p>
<blockquote class="last">
<div><p>The modified stc (method operates inplace).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.morph">
<tt class="descname">morph</tt><big>(</big><em>subject_to</em>, <em>grade=5</em>, <em>smooth=None</em>, <em>subjects_dir=None</em>, <em>buffer_size=64</em>, <em>n_jobs=1</em>, <em>subject_from=None</em>, <em>sparse=False</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.SourceEstimate.morph" title="Permalink to this definition">¶</a></dt>
<dd><p>Morph a source estimate from one subject to another</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>subject_to</strong> : string</p>
<blockquote>
<div><p>Name of the subject on which to morph as named in the SUBJECTS_DIR</p>
</div></blockquote>
<p><strong>grade</strong> : int, list (of two arrays), or None</p>
<blockquote>
<div><p>Resolution of the icosahedral mesh (typically 5). If None, all
vertices will be used (potentially filling the surface). If a list,
then values will be morphed to the set of vertices specified in
in grade[0] and grade[1]. Note that specifying the vertices (e.g.,
grade=[np.arange(10242), np.arange(10242)] for fsaverage on a
standard grade 5 source space) can be substantially faster than
computing vertex locations. Note that if subject=&#8217;fsaverage&#8217;
and &#8216;grade=5&#8217;, this set of vertices will automatically be used
(instead of computed) for speed, since this is a common morph.
NOTE : If sparse=True, grade has to be set to None.</p>
</div></blockquote>
<p><strong>smooth</strong> : int or None</p>
<blockquote>
<div><p>Number of iterations for the smoothing of the surface data.
If None, smooth is automatically defined to fill the surface
with non-zero values.</p>
</div></blockquote>
<p><strong>subjects_dir</strong> : string, or None</p>
<blockquote>
<div><p>Path to SUBJECTS_DIR if it is not set in the environment.</p>
</div></blockquote>
<p><strong>buffer_size</strong> : int</p>
<blockquote>
<div><p>Morph data in chunks of <cite>buffer_size</cite> time instants.
Saves memory when morphing long time intervals.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int</p>
<blockquote>
<div><p>Number of jobs to run in parallel.</p>
</div></blockquote>
<p><strong>subject_from</strong> : string</p>
<blockquote>
<div><p>Name of the original subject as named in the SUBJECTS_DIR.
If None, self.subject will be used.</p>
</div></blockquote>
<p><strong>sparse</strong> : bool</p>
<blockquote>
<div><p>Morph as a sparse source estimate. If True the only
parameters used are subject_to and subject_from,
and grade has to be None.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>stc_to</strong> : SourceEstimate</p>
<blockquote class="last">
<div><p>Source estimate for the destination subject.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.morph_precomputed">
<tt class="descname">morph_precomputed</tt><big>(</big><em>subject_to</em>, <em>vertices_to</em>, <em>morph_mat</em>, <em>subject_from=None</em><big>)</big><a class="headerlink" href="#mne.SourceEstimate.morph_precomputed" title="Permalink to this definition">¶</a></dt>
<dd><p>Morph source estimate between subjects using a precomputed matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>subject_to</strong> : string</p>
<blockquote>
<div><p>Name of the subject on which to morph as named in the SUBJECTS_DIR.</p>
</div></blockquote>
<p><strong>vertices_to</strong> : list of array of int</p>
<blockquote>
<div><p>The vertices on the destination subject&#8217;s brain.</p>
</div></blockquote>
<p><strong>morph_mat</strong> : sparse matrix</p>
<blockquote>
<div><p>The morphing matrix, usually from compute_morph_matrix.</p>
</div></blockquote>
<p><strong>subject_from</strong> : string | None</p>
<blockquote>
<div><p>Name of the original subject as named in the SUBJECTS_DIR.
If None, self.subject will be used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>stc_to</strong> : SourceEstimate</p>
<blockquote class="last">
<div><p>Source estimate for the destination subject.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.plot">
<tt class="descname">plot</tt><big>(</big><em>subject=None</em>, <em>surface='inflated'</em>, <em>hemi='lh'</em>, <em>colormap='auto'</em>, <em>time_label='time=%0.2f ms'</em>, <em>smoothing_steps=10</em>, <em>transparent=None</em>, <em>alpha=1.0</em>, <em>time_viewer=False</em>, <em>config_opts=None</em>, <em>subjects_dir=None</em>, <em>figure=None</em>, <em>views='lat'</em>, <em>colorbar=True</em>, <em>clim='auto'</em><big>)</big><a class="headerlink" href="#mne.SourceEstimate.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot SourceEstimates with PySurfer</p>
<p>Note: PySurfer currently needs the SUBJECTS_DIR environment variable,
which will automatically be set by this function. Plotting multiple
SourceEstimates with different values for subjects_dir will cause
PySurfer to use the wrong FreeSurfer surfaces when using methods of
the returned Brain object. It is therefore recommended to set the
SUBJECTS_DIR environment variable or always use the same value for
subjects_dir (within the same Python session).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>subject</strong> : str | None</p>
<blockquote>
<div><p>The subject name corresponding to FreeSurfer environment
variable SUBJECT. If None stc.subject will be used. If that
is None, the environment will be used.</p>
</div></blockquote>
<p><strong>surface</strong> : str</p>
<blockquote>
<div><p>The type of surface (inflated, white etc.).</p>
</div></blockquote>
<p><strong>hemi</strong> : str, &#8216;lh&#8217; | &#8216;rh&#8217; | &#8216;split&#8217; | &#8216;both&#8217;</p>
<blockquote>
<div><p>The hemisphere to display.</p>
</div></blockquote>
<p><strong>colormap</strong> : str | np.ndarray of float, shape(n_colors, 3 | 4)</p>
<blockquote>
<div><p>Name of colormap to use or a custom look up table. If array, must
be (n x 3) or (n x 4) array for with RGB or RGBA values between
0 and 255. If &#8216;auto&#8217;, either &#8216;hot&#8217; or &#8216;mne&#8217; will be chosen
based on whether &#8216;lims&#8217; or &#8216;pos_lims&#8217; are specified in <cite>clim</cite>.</p>
</div></blockquote>
<p><strong>time_label</strong> : str</p>
<blockquote>
<div><p>How to print info about the time instant visualized.</p>
</div></blockquote>
<p><strong>smoothing_steps</strong> : int</p>
<blockquote>
<div><p>The amount of smoothing.</p>
</div></blockquote>
<p><strong>transparent</strong> : bool | None</p>
<blockquote>
<div><p>If True, use a linear transparency between fmin and fmid.
None will choose automatically based on colormap type.</p>
</div></blockquote>
<p><strong>alpha</strong> : float</p>
<blockquote>
<div><p>Alpha value to apply globally to the overlay.</p>
</div></blockquote>
<p><strong>time_viewer</strong> : bool</p>
<blockquote>
<div><p>Display time viewer GUI.</p>
</div></blockquote>
<p><strong>config_opts</strong> : dict</p>
<blockquote>
<div><p>Keyword arguments for Brain initialization.
See pysurfer.viz.Brain.</p>
</div></blockquote>
<p><strong>subjects_dir</strong> : str</p>
<blockquote>
<div><p>The path to the FreeSurfer subjects reconstructions.
It corresponds to FreeSurfer environment variable SUBJECTS_DIR.</p>
</div></blockquote>
<p><strong>figure</strong> : instance of mayavi.core.scene.Scene | None</p>
<blockquote>
<div><p>If None, the last figure will be cleaned and a new figure will
be created.</p>
</div></blockquote>
<p><strong>views</strong> : str | list</p>
<blockquote>
<div><p>View to use. See surfer.Brain().</p>
</div></blockquote>
<p><strong>colorbar</strong> : bool</p>
<blockquote>
<div><p>If True, display colorbar on scene.</p>
</div></blockquote>
<p><strong>clim</strong> : str | dict</p>
<blockquote>
<div><p>Colorbar properties specification. If &#8216;auto&#8217;, set clim
automatically based on data percentiles. If dict, should contain:</p>
<blockquote>
<div><dl class="docutils">
<dt>kind <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Flag to specify type of limits. &#8216;value&#8217; or &#8216;percent&#8217;.</p>
</dd>
<dt>lims <span class="classifier-delimiter">:</span> <span class="classifier">list | np.ndarray | tuple of float, 3 elements</span></dt>
<dd><p class="first last">Note: Only use this if &#8216;colormap&#8217; is not &#8216;mne&#8217;.
Left, middle, and right bound for colormap.</p>
</dd>
<dt>pos_lims <span class="classifier-delimiter">:</span> <span class="classifier">list | np.ndarray | tuple of float, 3 elements</span></dt>
<dd><p class="first last">Note: Only use this if &#8216;colormap&#8217; is &#8216;mne&#8217;.
Left, middle, and right bound for colormap. Positive values
will be mirrored directly across zero during colormap
construction to obtain negative control points.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>brain</strong> : Brain</p>
<blockquote class="last">
<div><p>A instance of surfer.viz.Brain from PySurfer.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.resample">
<tt class="descname">resample</tt><big>(</big><em>sfreq</em>, <em>npad=None</em>, <em>window='boxcar'</em>, <em>n_jobs=1</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.SourceEstimate.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sfreq</strong> : float</p>
<blockquote>
<div><p>New sample rate to use.</p>
</div></blockquote>
<p><strong>npad</strong> : int | str</p>
<blockquote>
<div><p>Amount to pad the start and end of the data.
Can also be &#8220;auto&#8221; to use a padding that will result in
a power-of-two size (can be much faster).</p>
</div></blockquote>
<p><strong>window</strong> : string or tuple</p>
<blockquote>
<div><p>Window to use in resampling. See scipy.signal.resample.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int</p>
<blockquote>
<div><p>Number of jobs to run in parallel.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For some data, it may be more accurate to use npad=0 to reduce
artifacts. This is dataset dependent &#8211; check your data!</p>
<p>Note that the sample rate of the original data is inferred from tstep.</p>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.save">
<tt class="descname">save</tt><big>(</big><em>fname</em>, <em>ftype='stc'</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.SourceEstimate.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the source estimates to a file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fname</strong> : string</p>
<blockquote>
<div><p>The stem of the file name. The file names used for surface source
spaces are obtained by adding &#8220;-lh.stc&#8221; and &#8220;-rh.stc&#8221; (or &#8220;-lh.w&#8221;
and &#8220;-rh.w&#8221;) to the stem provided, for the left and the right
hemisphere, respectively.</p>
</div></blockquote>
<p><strong>ftype</strong> : string</p>
<blockquote>
<div><p>File format to use. Allowed values are &#8220;stc&#8221; (default), &#8220;w&#8221;,
and &#8220;h5&#8221;. The &#8220;w&#8221; format only supports a single time point.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mne.SourceEstimate.sfreq">
<tt class="descname">sfreq</tt><a class="headerlink" href="#mne.SourceEstimate.sfreq" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample rate of the data</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.SourceEstimate.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#mne.SourceEstimate.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Shape of the data</p>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.sqrt">
<tt class="descname">sqrt</tt><big>(</big><big>)</big><a class="headerlink" href="#mne.SourceEstimate.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the square root</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>stc</strong> : instance of SourceEstimate</p>
<blockquote class="last">
<div><p>A copy of the SourceEstimate with sqrt(data).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.time_as_index">
<tt class="descname">time_as_index</tt><big>(</big><em>times</em>, <em>use_rounding=False</em><big>)</big><a class="headerlink" href="#mne.SourceEstimate.time_as_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert time to indices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>times</strong> : list-like | float | int</p>
<blockquote>
<div><p>List of numbers or a number representing points in time.</p>
</div></blockquote>
<p><strong>use_rounding</strong> : boolean</p>
<blockquote>
<div><p>If True, use rounding (instead of truncation) when converting
times to indices. This can help avoid non-unique indices.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>index</strong> : ndarray</p>
<blockquote class="last">
<div><p>Indices corresponding to the times supplied.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.to_data_frame">
<tt class="descname">to_data_frame</tt><big>(</big><em>picks=None</em>, <em>index=None</em>, <em>scale_time=1000.0</em>, <em>scalings=None</em>, <em>copy=True</em>, <em>start=None</em>, <em>stop=None</em><big>)</big><a class="headerlink" href="#mne.SourceEstimate.to_data_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Export data in tabular structure as a pandas DataFrame.</p>
<p>Columns and indices will depend on the object being converted.
Generally this will include as much relevant information as
possible for the data type being converted. This makes it easy
to convert data for use in packages that utilize dataframes,
such as statsmodels or seaborn.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>If None only MEG and EEG channels are kept
otherwise the channels indices in picks are kept.</p>
</div></blockquote>
<p><strong>index</strong> : tuple of str | None</p>
<blockquote>
<div><p>Column to be used as index for the data. Valid string options
are &#8216;epoch&#8217;, &#8216;time&#8217; and &#8216;condition&#8217;. If None, all three info
columns will be included in the table as categorial data.</p>
</div></blockquote>
<p><strong>scale_time</strong> : float</p>
<blockquote>
<div><p>Scaling to be applied to time units.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | None</p>
<blockquote>
<div><p>Scaling to be applied to the channels picked. If None, defaults to
<tt class="docutils literal"><span class="pre">scalings=dict(eeg=1e6,</span> <span class="pre">grad=1e13,</span> <span class="pre">mag=1e15,</span> <span class="pre">misc=1.0)</span></tt>.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>If true, data will be copied. Else data may be modified in place.</p>
</div></blockquote>
<p><strong>start</strong> : int | None</p>
<blockquote>
<div><p>If it is a Raw object, this defines a starting index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</div></blockquote>
<p><strong>stop</strong> : int | None</p>
<blockquote>
<div><p>If it is a Raw object, this defines a stop index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>df</strong> : instance of pandas.core.DataFrame</p>
<blockquote class="last">
<div><p>A dataframe suitable for usage with other
statistical/plotting/analysis packages. Column/Index values will
depend on the object type being converted, but should be
human-readable.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.to_original_src">
<tt class="descname">to_original_src</tt><big>(</big><em>src_orig</em>, <em>subject_orig=None</em>, <em>subjects_dir=None</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.SourceEstimate.to_original_src" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a SourceEstimate from morphed source to the original subject</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>src_orig</strong> : instance of SourceSpaces</p>
<blockquote>
<div><p>The original source spaces that were morphed to the current
subject.</p>
</div></blockquote>
<p><strong>subject_orig</strong> : str | None</p>
<blockquote>
<div><p>The original subject. For most source spaces this shouldn&#8217;t need
to be provided, since it is stored in the source space itself.</p>
</div></blockquote>
<p><strong>subjects_dir</strong> : string, or None</p>
<blockquote>
<div><p>Path to SUBJECTS_DIR if it is not set in the environment.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.morph_source_spaces.html#mne.morph_source_spaces" title="mne.morph_source_spaces"><tt class="xref py py-obj docutils literal"><span class="pre">morph_source_spaces</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.10.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.transform">
<tt class="descname">transform</tt><big>(</big><em>func</em>, <em>idx=None</em>, <em>tmin=None</em>, <em>tmax=None</em>, <em>copy=False</em><big>)</big><a class="headerlink" href="#mne.SourceEstimate.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply linear transform</p>
<p>The transform is applied to each source time course independently.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>func</strong> : callable</p>
<blockquote>
<div><p>The transform to be applied, including parameters (see, e.g.,
mne.fixes.partial). The first parameter of the function is the
input data. The first two dimensions of the transformed data
should be (i) vertices and (ii) time.  Transforms which yield 3D
output (e.g. time-frequency transforms) are valid, so long as the
first two dimensions are vertices and time.  In this case, the
copy parameter (see below) must be True and a list of
SourceEstimates, rather than a single instance of SourceEstimate,
will be returned, one for each index of the 3rd dimension of the
transformed data.  In the case of transforms yielding 2D output
(e.g. filtering), the user has the option of modifying the input
inplace (copy = False) or returning a new instance of
SourceEstimate (copy = True) with the transformed data.</p>
</div></blockquote>
<p><strong>idx</strong> : array | None</p>
<blockquote>
<div><p>Indices of source time courses for which to compute transform.
If None, all time courses are used.</p>
</div></blockquote>
<p><strong>tmin</strong> : float | int | None</p>
<blockquote>
<div><p>First time point to include (ms). If None, self.tmin is used.</p>
</div></blockquote>
<p><strong>tmax</strong> : float | int | None</p>
<blockquote>
<div><p>Last time point to include (ms). If None, self.tmax is used.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>If True, return a new instance of SourceEstimate instead of
modifying the input inplace.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>stcs</strong> : instance of SourceEstimate | list</p>
<blockquote class="last">
<div><p>The transformed stc or, in the case of transforms which yield
N-dimensional output (where N &gt; 2), a list of stcs. For a list,
copy must be True.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Applying transforms can be significantly faster if the
SourceEstimate object was created using &#8220;(kernel, sens_data)&#8221;, for
the &#8220;data&#8221; parameter as the transform is applied in sensor space.
Inverse methods, e.g., &#8220;apply_inverse_epochs&#8221;, or &#8220;lcmv_epochs&#8221; do
this automatically (if possible).</p>
</dd></dl>

<dl class="method">
<dt id="mne.SourceEstimate.transform_data">
<tt class="descname">transform_data</tt><big>(</big><em>func</em>, <em>idx=None</em>, <em>tmin_idx=None</em>, <em>tmax_idx=None</em><big>)</big><a class="headerlink" href="#mne.SourceEstimate.transform_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Get data after a linear (time) transform has been applied</p>
<p>The transorm is applied to each source time course independently.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>func</strong> : callable</p>
<blockquote>
<div><p>The transform to be applied, including parameters (see, e.g.,
<cite>mne.fixes.partial</cite>). The first parameter of the function is the
input data. The first return value is the transformed data,
remaining outputs are ignored. The first dimension of the
transformed data has to be the same as the first dimension of the
input data.</p>
</div></blockquote>
<p><strong>idx</strong> : array | None</p>
<blockquote>
<div><p>Indicices of source time courses for which to compute transform.
If None, all time courses are used.</p>
</div></blockquote>
<p><strong>tmin_idx</strong> : int | None</p>
<blockquote>
<div><p>Index of first time point to include. If None, the index of the
first time point is used.</p>
</div></blockquote>
<p><strong>tmax_idx</strong> : int | None</p>
<blockquote>
<div><p>Index of the first time point not to include. If None, time points
up to (and including) the last time point are included.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>data_t</strong> : ndarray</p>
<blockquote class="last">
<div><p>The transformed data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Applying transforms can be significantly faster if the
SourceEstimate object was created using &#8220;(kernel, sens_data)&#8221;, for
the &#8220;data&#8221; parameter as the transform is applied in sensor space.
Inverse methods, e.g., &#8220;apply_inverse_epochs&#8221;, or &#8220;lcmv_epochs&#8221; do
this automatically (if possible).</p>
</dd></dl>

</dd></dl>

</div>


    </div>
    
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2012-2016, MNE Developers. Last updated on 2016-05-11.<br/>
    </p>
  </div>
</footer>
  </body>
</html>