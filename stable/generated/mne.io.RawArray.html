<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mne.io.RawArray &mdash; MNE 0.12.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootswatch-3.3.4/flatly/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.12.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.4/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="MNE 0.12.0 documentation" href="../index.html" />
    <link rel="up" title="Python API Reference" href="../python_reference.html" />
    <link rel="next" title="mne.create_info" href="mne.create_info.html" />
    <link rel="prev" title="mne.EpochsArray" href="mne.EpochsArray.html" />

<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,400,700' rel='stylesheet' type='text/css'>


    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37225609-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>



    <script type="text/javascript">
    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);
    js.id=id;js.src="http://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
    </script>



    <script type="text/javascript">
    (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    </script>


  </head>
  <body>





  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><img src="../_static/mne_logo_small.png">
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.12.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../getting_started.html">Get started</a></li>
                <li><a href="../tutorials.html">Tutorials</a></li>
                <li><a href="../auto_examples/index.html">Gallery</a></li>
                <li><a href="../python_reference.html">API</a></li>
                <li><a href="../manual/index.html">Manual</a></li>
                <li><a href="../faq.html">FAQ</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contribute to MNE</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../python_reference.html">Python API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../manual/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whats_new.html">What&#8217;s new</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cite.html">How to cite MNE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">Related publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cited.html">Publications from MNE users</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">mne.io.RawArray</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/mne_logo_small.png" alt="Logo"/>
            </a></p><ul>
<li><a class="reference internal" href="#">mne.io.RawArray</a></li>
</ul>

  <li>
    <a href="mne.EpochsArray.html" title="Previous Chapter: mne.EpochsArray"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; mne.EpochsArray</span>
    </a>
  </li>
  <li>
    <a href="mne.create_info.html" title="Next Chapter: mne.create_info"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">mne.create_info &raquo;</span>
    </a>
  </li>
<form action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="col-md-12">
      
  <div class="section" id="mne-io-rawarray">
<h1>mne.io.RawArray<a class="headerlink" href="#mne-io-rawarray" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="mne.io.RawArray">
<em class="property">class </em><tt class="descclassname">mne.io.</tt><tt class="descname">RawArray</tt><big>(</big><em>data</em>, <em>info</em>, <em>first_samp=0</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Raw object from numpy array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array, shape (n_channels, n_times)</p>
<blockquote>
<div><p>The channels&#8217; time series.</p>
</div></blockquote>
<p><strong>info</strong> : instance of Info</p>
<blockquote>
<div><p>Info dictionary. Consider using <cite>create_info</cite> to populate
this structure. This may be modified in place by the class.</p>
</div></blockquote>
<p><strong>first_samp</strong> : int</p>
<blockquote>
<div><p>First sample offset used during recording (default 0).</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.12.</span></p>
</div>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">EpochsArray</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">EvokedArray</span></tt>, <tt class="xref py py-obj docutils literal"><span class="pre">create_info</span></tt></p>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.add_channels" title="mne.io.RawArray.add_channels"><tt class="xref py py-obj docutils literal"><span class="pre">add_channels</span></tt></a>(add_list[,&nbsp;copy,&nbsp;force_update_info])</td>
<td>Append new channels to the instance.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.add_eeg_average_proj" title="mne.io.RawArray.add_eeg_average_proj"><tt class="xref py py-obj docutils literal"><span class="pre">add_eeg_average_proj</span></tt></a>()</td>
<td>Add an average EEG reference projector if one does not exist</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.add_events" title="mne.io.RawArray.add_events"><tt class="xref py py-obj docutils literal"><span class="pre">add_events</span></tt></a>(events[,&nbsp;stim_channel])</td>
<td>Add events to stim channel</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.add_proj" title="mne.io.RawArray.add_proj"><tt class="xref py py-obj docutils literal"><span class="pre">add_proj</span></tt></a>(projs[,&nbsp;remove_existing,&nbsp;verbose])</td>
<td>Add SSP projection vectors</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.anonymize" title="mne.io.RawArray.anonymize"><tt class="xref py py-obj docutils literal"><span class="pre">anonymize</span></tt></a>()</td>
<td>Anonymize data</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.append" title="mne.io.RawArray.append"><tt class="xref py py-obj docutils literal"><span class="pre">append</span></tt></a>(raws[,&nbsp;preload])</td>
<td>Concatenate raw instances as if they were continuous</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.apply_function" title="mne.io.RawArray.apply_function"><tt class="xref py py-obj docutils literal"><span class="pre">apply_function</span></tt></a>(fun,&nbsp;picks,&nbsp;dtype,&nbsp;n_jobs,&nbsp;...)</td>
<td>Apply a function to a subset of channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.apply_hilbert" title="mne.io.RawArray.apply_hilbert"><tt class="xref py py-obj docutils literal"><span class="pre">apply_hilbert</span></tt></a>(picks[,&nbsp;envelope,&nbsp;n_jobs,&nbsp;...])</td>
<td>Compute analytic signal or envelope for a subset of channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.apply_proj" title="mne.io.RawArray.apply_proj"><tt class="xref py py-obj docutils literal"><span class="pre">apply_proj</span></tt></a>()</td>
<td>Apply the signal space projection (SSP) operators to the data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.close" title="mne.io.RawArray.close"><tt class="xref py py-obj docutils literal"><span class="pre">close</span></tt></a>()</td>
<td>Clean up the object.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.copy" title="mne.io.RawArray.copy"><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt></a>()</td>
<td>Return copy of Raw instance</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.crop" title="mne.io.RawArray.crop"><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt></a>([tmin,&nbsp;tmax,&nbsp;copy])</td>
<td>Crop raw data file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.del_proj" title="mne.io.RawArray.del_proj"><tt class="xref py py-obj docutils literal"><span class="pre">del_proj</span></tt></a>(idx)</td>
<td>Remove SSP projection vector</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.drop_channels" title="mne.io.RawArray.drop_channels"><tt class="xref py py-obj docutils literal"><span class="pre">drop_channels</span></tt></a>(ch_names[,&nbsp;copy])</td>
<td>Drop some channels</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.estimate_rank" title="mne.io.RawArray.estimate_rank"><tt class="xref py py-obj docutils literal"><span class="pre">estimate_rank</span></tt></a>([tstart,&nbsp;tstop,&nbsp;tol,&nbsp;...])</td>
<td>Estimate rank of the raw data</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.filter" title="mne.io.RawArray.filter"><tt class="xref py py-obj docutils literal"><span class="pre">filter</span></tt></a>(l_freq,&nbsp;h_freq[,&nbsp;picks,&nbsp;...])</td>
<td>Filter a subset of channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.index_as_time" title="mne.io.RawArray.index_as_time"><tt class="xref py py-obj docutils literal"><span class="pre">index_as_time</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">DEPRECATED: index_as_time is deprecated and will be removed in 0.13, use raw.times[idx] (or raw.times[idx + raw.first_samp] instead</p>
</div>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.interpolate_bads" title="mne.io.RawArray.interpolate_bads"><tt class="xref py py-obj docutils literal"><span class="pre">interpolate_bads</span></tt></a>([reset_bads,&nbsp;mode])</td>
<td>Interpolate bad MEG and EEG channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.load_bad_channels" title="mne.io.RawArray.load_bad_channels"><tt class="xref py py-obj docutils literal"><span class="pre">load_bad_channels</span></tt></a>([bad_file,&nbsp;force])</td>
<td>Mark channels as bad from a text file</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.load_data" title="mne.io.RawArray.load_data"><tt class="xref py py-obj docutils literal"><span class="pre">load_data</span></tt></a>([verbose])</td>
<td>Load raw data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.notch_filter" title="mne.io.RawArray.notch_filter"><tt class="xref py py-obj docutils literal"><span class="pre">notch_filter</span></tt></a>(freqs[,&nbsp;picks,&nbsp;filter_length,&nbsp;...])</td>
<td>Notch filter a subset of channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.pick_channels" title="mne.io.RawArray.pick_channels"><tt class="xref py py-obj docutils literal"><span class="pre">pick_channels</span></tt></a>(ch_names[,&nbsp;copy])</td>
<td>Pick some channels</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.pick_types" title="mne.io.RawArray.pick_types"><tt class="xref py py-obj docutils literal"><span class="pre">pick_types</span></tt></a>([meg,&nbsp;eeg,&nbsp;stim,&nbsp;eog,&nbsp;ecg,&nbsp;emg,&nbsp;...])</td>
<td>Pick some channels by type and names</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.plot" title="mne.io.RawArray.plot"><tt class="xref py py-obj docutils literal"><span class="pre">plot</span></tt></a>([events,&nbsp;duration,&nbsp;start,&nbsp;n_channels,&nbsp;...])</td>
<td>Plot raw data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.plot_projs_topomap" title="mne.io.RawArray.plot_projs_topomap"><tt class="xref py py-obj docutils literal"><span class="pre">plot_projs_topomap</span></tt></a>([ch_type,&nbsp;layout,&nbsp;axes])</td>
<td>Plot SSP vector</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.plot_psd" title="mne.io.RawArray.plot_psd"><tt class="xref py py-obj docutils literal"><span class="pre">plot_psd</span></tt></a>([tmin,&nbsp;tmax,&nbsp;fmin,&nbsp;fmax,&nbsp;proj,&nbsp;...])</td>
<td>Plot the power spectral density across channels</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.plot_psd_topo" title="mne.io.RawArray.plot_psd_topo"><tt class="xref py py-obj docutils literal"><span class="pre">plot_psd_topo</span></tt></a>([tmin,&nbsp;tmax,&nbsp;fmin,&nbsp;fmax,&nbsp;...])</td>
<td>Function for plotting channel wise frequency spectra as topography.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.plot_sensors" title="mne.io.RawArray.plot_sensors"><tt class="xref py py-obj docutils literal"><span class="pre">plot_sensors</span></tt></a>([kind,&nbsp;ch_type,&nbsp;title,&nbsp;...])</td>
<td>Plot sensors positions.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.rename_channels" title="mne.io.RawArray.rename_channels"><tt class="xref py py-obj docutils literal"><span class="pre">rename_channels</span></tt></a>(mapping)</td>
<td>Rename channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.resample" title="mne.io.RawArray.resample"><tt class="xref py py-obj docutils literal"><span class="pre">resample</span></tt></a>(sfreq[,&nbsp;npad,&nbsp;window,&nbsp;stim_picks,&nbsp;...])</td>
<td>Resample all channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.save" title="mne.io.RawArray.save"><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt></a>(fname[,&nbsp;picks,&nbsp;tmin,&nbsp;tmax,&nbsp;...])</td>
<td>Save raw data to file</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.set_channel_types" title="mne.io.RawArray.set_channel_types"><tt class="xref py py-obj docutils literal"><span class="pre">set_channel_types</span></tt></a>(mapping)</td>
<td>Define the sensor type of channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.set_montage" title="mne.io.RawArray.set_montage"><tt class="xref py py-obj docutils literal"><span class="pre">set_montage</span></tt></a>(montage[,&nbsp;verbose])</td>
<td>Set EEG sensor configuration</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.io.RawArray.time_as_index" title="mne.io.RawArray.time_as_index"><tt class="xref py py-obj docutils literal"><span class="pre">time_as_index</span></tt></a>(times[,&nbsp;use_first_samp,&nbsp;...])</td>
<td>Convert time to indices</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.io.RawArray.to_data_frame" title="mne.io.RawArray.to_data_frame"><tt class="xref py py-obj docutils literal"><span class="pre">to_data_frame</span></tt></a>([picks,&nbsp;index,&nbsp;scale_time,&nbsp;...])</td>
<td>Export data in tabular structure as a pandas DataFrame.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="mne.io.RawArray.__init__">
<tt class="descname">__init__</tt><big>(</big><em>data</em>, <em>info</em>, <em>first_samp=0</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.add_channels">
<tt class="descname">add_channels</tt><big>(</big><em>add_list</em>, <em>copy=None</em>, <em>force_update_info=False</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.add_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Append new channels to the instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>add_list</strong> : list</p>
<blockquote>
<div><p>A list of objects to append to self. Must contain all the same
type as the current object</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>This parameter has been deprecated and will be removed in 0.13.
Use inst.copy() instead.
Whether to return a new instance or modify in place.</p>
</div></blockquote>
<p><strong>force_update_info</strong> : bool</p>
<blockquote>
<div><p>If True, force the info for objects to be appended to match the
values in <cite>self</cite>. This should generally only be used when adding
stim channels for which important metadata won&#8217;t be overwritten.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.12.</span></p>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.add_eeg_average_proj">
<tt class="descname">add_eeg_average_proj</tt><big>(</big><big>)</big><a class="headerlink" href="#mne.io.RawArray.add_eeg_average_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an average EEG reference projector if one does not exist</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.add_events">
<tt class="descname">add_events</tt><big>(</big><em>events</em>, <em>stim_channel=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.add_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Add events to stim channel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>events</strong> : ndarray, shape (n_events, 3)</p>
<blockquote>
<div><p>Events to add. The first column specifies the sample number of
each event, the second column is ignored, and the third column
provides the event value. If events already exist in the Raw
instance at the given sample numbers, the event values will be
added together.</p>
</div></blockquote>
<p><strong>stim_channel</strong> : str | None</p>
<blockquote class="last">
<div><p>Name of the stim channel to add to. If None, the config variable
&#8216;MNE_STIM_CHANNEL&#8217; is used. If this is not found, it will default
to &#8216;STI 014&#8217;.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Data must be preloaded in order to add events.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.add_proj">
<tt class="descname">add_proj</tt><big>(</big><em>projs</em>, <em>remove_existing=False</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.add_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Add SSP projection vectors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>projs</strong> : list</p>
<blockquote>
<div><p>List with projection vectors.</p>
</div></blockquote>
<p><strong>remove_existing</strong> : bool</p>
<blockquote>
<div><p>Remove the projection vectors currently in the file.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : instance of Raw | Epochs | Evoked</p>
<blockquote class="last">
<div><p>The data container.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.anonymize">
<tt class="descname">anonymize</tt><big>(</big><big>)</big><a class="headerlink" href="#mne.io.RawArray.anonymize" title="Permalink to this definition">¶</a></dt>
<dd><p>Anonymize data</p>
<p>This function will remove <tt class="docutils literal"><span class="pre">raw.info['subject_info']</span></tt> if it exists.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>raw</strong> : instance of Raw</p>
<blockquote class="last">
<div><p>The raw object. Operates in place.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.append">
<tt class="descname">append</tt><big>(</big><em>raws</em>, <em>preload=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate raw instances as if they were continuous</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>raws</strong> : list, or Raw instance</p>
<blockquote>
<div><p>list of Raw instances to concatenate to the current instance
(in order), or a single raw instance to concatenate.</p>
</div></blockquote>
<p><strong>preload</strong> : bool, str, or None (default None)</p>
<blockquote class="last">
<div><p>Preload data into memory for data manipulation and faster indexing.
If True, the data will be preloaded into memory (fast, requires
large amount of memory). If preload is a string, preload is the
file name of a memory-mapped file which is used to store the data
on the hard drive (slower, requires less memory). If preload is
None, preload=True or False is inferred using the preload status
of the raw files passed in.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.apply_function">
<tt class="descname">apply_function</tt><big>(</big><em>fun</em>, <em>picks</em>, <em>dtype</em>, <em>n_jobs</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.apply_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a function to a subset of channels.</p>
<p>The function &#8220;fun&#8221; is applied to the channels defined in &#8220;picks&#8221;. The
data of the Raw object is modified inplace. If the function returns
a different data type (e.g. numpy.complex) it must be specified using
the dtype parameter, which causes the data type used for representing
the raw data to change.</p>
<p>The Raw object has to have the data loaded e.g. with <tt class="docutils literal"><span class="pre">preload=True</span></tt>
or <tt class="docutils literal"><span class="pre">self.load_data()</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If n_jobs &gt; 1, more memory is required as
<tt class="docutils literal"><span class="pre">len(picks)</span> <span class="pre">*</span> <span class="pre">n_times</span></tt> additional time points need to
be temporaily stored in memory.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the data type changes (dtype != None), more memory is
required since the original and the converted data needs
to be stored in memory.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fun</strong> : function</p>
<blockquote>
<div><p>A function to be applied to the channels. The first argument of
fun has to be a timeseries (numpy.ndarray). The function must
return an numpy.ndarray with the same size as the input.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>Indices of channels to apply the function to. If None, all
M-EEG channels are used.</p>
</div></blockquote>
<p><strong>dtype</strong> : numpy.dtype</p>
<blockquote>
<div><p>Data type to use for raw data after applying the function. If None
the data type is not modified.</p>
</div></blockquote>
<p><strong>n_jobs: int</strong> :</p>
<blockquote>
<div><p>Number of jobs to run in parallel.</p>
</div></blockquote>
<p><strong>*args :</strong> :</p>
<blockquote>
<div><p>Additional positional arguments to pass to fun (first pos. argument
of fun is the timeseries of a channel).</p>
</div></blockquote>
<p><strong>**kwargs :</strong> :</p>
<blockquote class="last">
<div><p>Keyword arguments to pass to fun. Note that if &#8220;verbose&#8221; is passed
as a member of <tt class="docutils literal"><span class="pre">kwargs</span></tt>, it will be consumed and will override
the default mne-python verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.apply_hilbert">
<tt class="descname">apply_hilbert</tt><big>(</big><em>picks</em>, <em>envelope=False</em>, <em>n_jobs=1</em>, <em>n_fft=None</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.apply_hilbert" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute analytic signal or envelope for a subset of channels.</p>
<p>If envelope=False, the analytic signal for the channels defined in
&#8220;picks&#8221; is computed and the data of the Raw object is converted to
a complex representation (the analytic signal is complex valued).</p>
<p>If envelope=True, the absolute value of the analytic signal for the
channels defined in &#8220;picks&#8221; is computed, resulting in the envelope
signal.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If envelope=False, more memory is required since the
original raw data as well as the analytic signal have
temporarily to be stored in memory.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If n_jobs &gt; 1, more memory is required as
<tt class="docutils literal"><span class="pre">len(picks)</span> <span class="pre">*</span> <span class="pre">n_times</span></tt> additional time points need to
be temporaily stored in memory.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : array-like of int</p>
<blockquote>
<div><p>Indices of channels to apply the function to.</p>
</div></blockquote>
<p><strong>envelope</strong> : bool (default: False)</p>
<blockquote>
<div><p>Compute the envelope signal of each channel.</p>
</div></blockquote>
<p><strong>n_jobs: int</strong> :</p>
<blockquote>
<div><p>Number of jobs to run in parallel.</p>
</div></blockquote>
<p><strong>n_fft</strong> : int &gt; self.n_times | None</p>
<blockquote>
<div><p>Points to use in the FFT for Hilbert transformation. The signal
will be padded with zeros before computing Hilbert, then cut back
to original length. If None, n == self.n_times.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The analytic signal &#8220;x_a(t)&#8221; of &#8220;x(t)&#8221; is:</p>
<div class="highlight-python"><div class="highlight"><pre>x_a = F^{-1}(F(x) 2U) = x + i y
</pre></div>
</div>
<p>where &#8220;F&#8221; is the Fourier transform, &#8220;U&#8221; the unit step function,
and &#8220;y&#8221; the Hilbert transform of &#8220;x&#8221;. One usage of the analytic
signal is the computation of the envelope signal, which is given by
&#8220;e(t) = abs(x_a(t))&#8221;. Due to the linearity of Hilbert transform and the
MNE inverse solution, the enevlope in source space can be obtained
by computing the analytic signal in sensor space, applying the MNE
inverse, and computing the envelope in source space.</p>
<p>Also note that the n_fft parameter will allow you to pad the signal
with zeros before performing the Hilbert transform. This padding
is cut off, but it may result in a slightly different result
(particularly around the edges). Use at your own risk.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.apply_proj">
<tt class="descname">apply_proj</tt><big>(</big><big>)</big><a class="headerlink" href="#mne.io.RawArray.apply_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the signal space projection (SSP) operators to the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : instance of Raw | Epochs | Evoked</p>
<blockquote class="last">
<div><p>The instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Once the projectors have been applied, they can no longer be
removed. It is usually not recommended to apply the projectors at
too early stages, as they are applied automatically later on
(e.g. when computing inverse solutions).
Hint: using the copy method individual projection vectors
can be tested without affecting the original data.
With evoked data, consider the following example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">projs_a</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_proj</span><span class="p">(</span><span class="s1">&#39;proj_a.fif&#39;</span><span class="p">)</span>
<span class="n">projs_b</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_proj</span><span class="p">(</span><span class="s1">&#39;proj_b.fif&#39;</span><span class="p">)</span>
<span class="c1"># add the first, copy, apply and see ...</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">add_proj</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="c1"># add the second, copy, apply and see ...</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">add_proj</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="c1"># drop the first and see again</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">del_proj</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span>  <span class="c1"># finally keep both</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mne.io.RawArray.ch_names">
<tt class="descname">ch_names</tt><a class="headerlink" href="#mne.io.RawArray.ch_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Channel names</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#mne.io.RawArray.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up the object.</p>
<p>Does nothing for objects that close their file descriptors.
Things like RawFIF will override this method.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#mne.io.RawArray.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return copy of Raw instance</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.crop">
<tt class="descname">crop</tt><big>(</big><em>tmin=0.0</em>, <em>tmax=None</em>, <em>copy=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop raw data file.</p>
<p>Limit the data from the raw file to go between specific times. Note
that the new tmin is assumed to be t=0 for all subsequently called
functions (e.g., time_as_index, or Epochs). New first_samp and
last_samp are set accordingly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tmin</strong> : float</p>
<blockquote>
<div><p>New start time in seconds (must be &gt;= 0).</p>
</div></blockquote>
<p><strong>tmax</strong> : float | None</p>
<blockquote>
<div><p>New end time in seconds of the data (cannot exceed data duration).</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>This parameter has been deprecated and will be removed in 0.13.
Use inst.copy() instead.
Whether to return a new instance or modify in place.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>raw</strong> : instance of Raw</p>
<blockquote class="last">
<div><p>The cropped raw object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.del_proj">
<tt class="descname">del_proj</tt><big>(</big><em>idx</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.del_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove SSP projection vector</p>
<dl class="docutils">
<dt>Note: The projection vector can only be removed if it is inactive</dt>
<dd>(has not been applied to the data).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>idx</strong> : int</p>
<blockquote>
<div><p>Index of the projector to remove.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>self</strong> : instance of Raw | Epochs | Evoked</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.drop_channels">
<tt class="descname">drop_channels</tt><big>(</big><em>ch_names</em>, <em>copy=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.drop_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop some channels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_names</strong> : list</p>
<blockquote>
<div><p>The list of channels to remove.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>This parameter has been deprecated and will be removed in 0.13.
Use inst.copy() instead.
Whether to return a new instance or modify in place.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.io.RawArray.pick_channels" title="mne.io.RawArray.pick_channels"><tt class="xref py py-obj docutils literal"><span class="pre">pick_channels</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.estimate_rank">
<tt class="descname">estimate_rank</tt><big>(</big><em>tstart=0.0</em>, <em>tstop=30.0</em>, <em>tol=0.0001</em>, <em>return_singular=False</em>, <em>picks=None</em>, <em>scalings='norm'</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.estimate_rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate rank of the raw data</p>
<p>This function is meant to provide a reasonable estimate of the rank.
The true rank of the data depends on many factors, so use at your
own risk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tstart</strong> : float</p>
<blockquote>
<div><p>Start time to use for rank estimation. Default is 0.0.</p>
</div></blockquote>
<p><strong>tstop</strong> : float | None</p>
<blockquote>
<div><p>End time to use for rank estimation. Default is 30.0.
If None, the end time of the raw file is used.</p>
</div></blockquote>
<p><strong>tol</strong> : float</p>
<blockquote>
<div><p>Tolerance for singular values to consider non-zero in
calculating the rank. The singular values are calculated
in this method such that independent data are expected to
have singular value around one.</p>
</div></blockquote>
<p><strong>return_singular</strong> : bool</p>
<blockquote>
<div><p>If True, also return the singular values that were used
to determine the rank.</p>
</div></blockquote>
<p><strong>picks</strong> : array_like of int, shape (n_selected_channels,)</p>
<blockquote>
<div><p>The channels to be considered for rank estimation.
If None (default) meg and eeg channels are included.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | &#8216;norm&#8217;</p>
<blockquote>
<div><p>To achieve reliable rank estimation on multiple sensors,
sensors have to be rescaled. This parameter controls the
rescaling. If dict, it will update the
following dict of defaults:</p>
<blockquote>
<div><p>dict(mag=1e11, grad=1e9, eeg=1e5)</p>
</div></blockquote>
<p>If &#8216;norm&#8217; data will be scaled by internally computed
channel-wise norms.
Defaults to &#8216;norm&#8217;.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rank</strong> : int</p>
<blockquote>
<div><p>Estimated rank of the data.</p>
</div></blockquote>
<p><strong>s</strong> : array</p>
<blockquote class="last">
<div><p>If return_singular is True, the singular values that were
thresholded to determine the rank are also returned.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If data are not pre-loaded, the appropriate data will be loaded
by this function (can be memory intensive).</p>
<p>Projectors are not taken into account unless they have been applied
to the data using apply_proj(), since it is not always possible
to tell whether or not projectors have been applied previously.</p>
<p>Bad channels will be excluded from calculations.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.filter">
<tt class="descname">filter</tt><big>(</big><em>l_freq</em>, <em>h_freq</em>, <em>picks=None</em>, <em>filter_length='10s'</em>, <em>l_trans_bandwidth=0.5</em>, <em>h_trans_bandwidth=0.5</em>, <em>n_jobs=1</em>, <em>method='fft'</em>, <em>iir_params=None</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter a subset of channels.</p>
<p>Applies a zero-phase low-pass, high-pass, band-pass, or band-stop
filter to the channels selected by <tt class="docutils literal"><span class="pre">picks</span></tt>. By default the data
of the Raw object is modified inplace.</p>
<p>The Raw object has to have the data loaded e.g. with <tt class="docutils literal"><span class="pre">preload=True</span></tt>
or <tt class="docutils literal"><span class="pre">self.load_data()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">l_freq</span></tt> and <tt class="docutils literal"><span class="pre">h_freq</span></tt> are the frequencies below which and above
which, respectively, to filter out of the data. Thus the uses are:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">l_freq</span> <span class="pre">&lt;</span> <span class="pre">h_freq</span></tt>: band-pass filter</li>
<li><tt class="docutils literal"><span class="pre">l_freq</span> <span class="pre">&gt;</span> <span class="pre">h_freq</span></tt>: band-stop filter</li>
<li><tt class="docutils literal"><span class="pre">l_freq</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span> <span class="pre">and</span> <span class="pre">h_freq</span> <span class="pre">is</span> <span class="pre">None</span></tt>: high-pass filter</li>
<li><tt class="docutils literal"><span class="pre">l_freq</span> <span class="pre">is</span> <span class="pre">None</span> <span class="pre">and</span> <span class="pre">h_freq</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></tt>: low-pass filter</li>
</ul>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">self.info['lowpass']</span></tt> and <tt class="docutils literal"><span class="pre">self.info['highpass']</span></tt> are only
updated with picks=None.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If n_jobs &gt; 1, more memory is required as
<tt class="docutils literal"><span class="pre">len(picks)</span> <span class="pre">*</span> <span class="pre">n_times</span></tt> additional time points need to
be temporaily stored in memory.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>l_freq</strong> : float | None</p>
<blockquote>
<div><p>Low cut-off frequency in Hz. If None the data are only low-passed.</p>
</div></blockquote>
<p><strong>h_freq</strong> : float | None</p>
<blockquote>
<div><p>High cut-off frequency in Hz. If None the data are only
high-passed.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>Indices of channels to filter. If None only the data (MEG/EEG)
channels will be filtered.</p>
</div></blockquote>
<p><strong>filter_length</strong> : str (Default: &#8216;10s&#8217;) | int | None</p>
<blockquote>
<div><p>Length of the filter to use. If None or &#8220;len(x) &lt; filter_length&#8221;,
the filter length used is len(x). Otherwise, if int, overlap-add
filtering with a filter of the specified length in samples) is
used (faster for long signals). If str, a human-readable time in
units of &#8220;s&#8221; or &#8220;ms&#8221; (e.g., &#8220;10s&#8221; or &#8220;5500ms&#8221;) will be converted
to the shortest power-of-two length at least that duration.
Not used for &#8216;iir&#8217; filters.</p>
</div></blockquote>
<p><strong>l_trans_bandwidth</strong> : float</p>
<blockquote>
<div><p>Width of the transition band at the low cut-off frequency in Hz
(high pass or cutoff 1 in bandpass). Not used if &#8216;order&#8217; is
specified in iir_params.</p>
</div></blockquote>
<p><strong>h_trans_bandwidth</strong> : float</p>
<blockquote>
<div><p>Width of the transition band at the high cut-off frequency in Hz
(low pass or cutoff 2 in bandpass). Not used if &#8216;order&#8217; is
specified in iir_params.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int | str</p>
<blockquote>
<div><p>Number of jobs to run in parallel. Can be &#8216;cuda&#8217; if scikits.cuda
is installed properly, CUDA is initialized, and method=&#8217;fft&#8217;.</p>
</div></blockquote>
<p><strong>method</strong> : str</p>
<blockquote>
<div><p>&#8216;fft&#8217; will use overlap-add FIR filtering, &#8216;iir&#8217; will use IIR
forward-backward filtering (via filtfilt).</p>
</div></blockquote>
<p><strong>iir_params</strong> : dict | None</p>
<blockquote>
<div><p>Dictionary of parameters to use for IIR filtering.
See mne.filter.construct_iir_filter for details. If iir_params
is None and method=&#8221;iir&#8221;, 4th order Butterworth will be used.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>raw</strong> : instance of Raw</p>
<blockquote class="last">
<div><p>The raw instance with filtered data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.Epochs.html#mne.Epochs.savgol_filter" title="mne.Epochs.savgol_filter"><tt class="xref py py-obj docutils literal"><span class="pre">mne.Epochs.savgol_filter</span></tt></a>, <a class="reference internal" href="mne.io.Raw.html#mne.io.Raw.notch_filter" title="mne.io.Raw.notch_filter"><tt class="xref py py-obj docutils literal"><span class="pre">mne.io.Raw.notch_filter</span></tt></a>, <a class="reference internal" href="mne.io.Raw.html#mne.io.Raw.resample" title="mne.io.Raw.resample"><tt class="xref py py-obj docutils literal"><span class="pre">mne.io.Raw.resample</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.index_as_time">
<tt class="descname">index_as_time</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.index_as_time" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">DEPRECATED: index_as_time is deprecated and will be removed in 0.13, use raw.times[idx] (or raw.times[idx + raw.first_samp] instead</p>
</div>
<p>Convert indices to time</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>index</strong> : list-like | int</p>
<blockquote>
<div><blockquote>
<div><p>List of ints or int representing points in time.</p>
</div></blockquote>
<dl class="docutils">
<dt>use_first_samp <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">If True, the time returned is relative to the session onset, else
relative to the recording onset.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>times</strong> : ndarray</p>
<blockquote class="last">
<div><p>Times corresponding to the index supplied.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.interpolate_bads">
<tt class="descname">interpolate_bads</tt><big>(</big><em>reset_bads=True</em>, <em>mode='accurate'</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.interpolate_bads" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate bad MEG and EEG channels.</p>
<p>Operates in place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reset_bads</strong> : bool</p>
<blockquote>
<div><p>If True, remove the bads from info.</p>
</div></blockquote>
<p><strong>mode</strong> : str</p>
<blockquote>
<div><p>Either <cite>&#8216;accurate&#8217;</cite> or <cite>&#8216;fast&#8217;</cite>, determines the quality of the
Legendre polynomial expansion used for interpolation of MEG
channels.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.load_bad_channels">
<tt class="descname">load_bad_channels</tt><big>(</big><em>bad_file=None</em>, <em>force=False</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.load_bad_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark channels as bad from a text file</p>
<p>This function operates mostly in the style of the C function
<tt class="docutils literal"><span class="pre">mne_mark_bad_channels</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bad_file</strong> : string</p>
<blockquote>
<div><p>File name of the text file containing bad channels
If bad_file = None, bad channels are cleared, but this
is more easily done directly as raw.info[&#8216;bads&#8217;] = [].</p>
</div></blockquote>
<p><strong>force</strong> : boolean</p>
<blockquote class="last">
<div><p>Whether or not to force bad channel marking (of those
that exist) if channels are not found, instead of
raising an error.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.load_data">
<tt class="descname">load_data</tt><big>(</big><em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.load_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Load raw data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>raw</strong> : instance of Raw</p>
<blockquote class="last">
<div><p>The raw object with data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function will load raw data if it was not already preloaded.
If data were already preloaded, it will do nothing.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.10.0.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mne.io.RawArray.n_times">
<tt class="descname">n_times</tt><a class="headerlink" href="#mne.io.RawArray.n_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of time points</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.notch_filter">
<tt class="descname">notch_filter</tt><big>(</big><em>freqs</em>, <em>picks=None</em>, <em>filter_length='10s'</em>, <em>notch_widths=None</em>, <em>trans_bandwidth=1.0</em>, <em>n_jobs=1</em>, <em>method='fft'</em>, <em>iir_params=None</em>, <em>mt_bandwidth=None</em>, <em>p_value=0.05</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.notch_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Notch filter a subset of channels.</p>
<p>Applies a zero-phase notch filter to the channels selected by
&#8220;picks&#8221;. By default the data of the Raw object is modified inplace.</p>
<p>The Raw object has to have the data loaded e.g. with <tt class="docutils literal"><span class="pre">preload=True</span></tt>
or <tt class="docutils literal"><span class="pre">self.load_data()</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If n_jobs &gt; 1, more memory is required as
<tt class="docutils literal"><span class="pre">len(picks)</span> <span class="pre">*</span> <span class="pre">n_times</span></tt> additional time points need to
be temporaily stored in memory.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>freqs</strong> : float | array of float | None</p>
<blockquote>
<div><p>Specific frequencies to filter out from data, e.g.,
np.arange(60, 241, 60) in the US or np.arange(50, 251, 50) in
Europe. None can only be used with the mode &#8216;spectrum_fit&#8217;,
where an F test is used to find sinusoidal components.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>Indices of channels to filter. If None only the data (MEG/EEG)
channels will be filtered.</p>
</div></blockquote>
<p><strong>filter_length</strong> : str (Default: &#8216;10s&#8217;) | int | None</p>
<blockquote>
<div><p>Length of the filter to use. If None or &#8220;len(x) &lt; filter_length&#8221;,
the filter length used is len(x). Otherwise, if int, overlap-add
filtering with a filter of the specified length in samples) is
used (faster for long signals). If str, a human-readable time in
units of &#8220;s&#8221; or &#8220;ms&#8221; (e.g., &#8220;10s&#8221; or &#8220;5500ms&#8221;) will be converted
to the shortest power-of-two length at least that duration.
Not used for &#8216;iir&#8217; filters.</p>
</div></blockquote>
<p><strong>notch_widths</strong> : float | array of float | None</p>
<blockquote>
<div><p>Width of each stop band (centred at each freq in freqs) in Hz.
If None, freqs / 200 is used.</p>
</div></blockquote>
<p><strong>trans_bandwidth</strong> : float</p>
<blockquote>
<div><p>Width of the transition band in Hz.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int | str</p>
<blockquote>
<div><p>Number of jobs to run in parallel. Can be &#8216;cuda&#8217; if scikits.cuda
is installed properly, CUDA is initialized, and method=&#8217;fft&#8217;.</p>
</div></blockquote>
<p><strong>method</strong> : str</p>
<blockquote>
<div><p>&#8216;fft&#8217; will use overlap-add FIR filtering, &#8216;iir&#8217; will use IIR
forward-backward filtering (via filtfilt). &#8216;spectrum_fit&#8217; will
use multi-taper estimation of sinusoidal components.</p>
</div></blockquote>
<p><strong>iir_params</strong> : dict | None</p>
<blockquote>
<div><p>Dictionary of parameters to use for IIR filtering.
See mne.filter.construct_iir_filter for details. If iir_params
is None and method=&#8221;iir&#8221;, 4th order Butterworth will be used.</p>
</div></blockquote>
<p><strong>mt_bandwidth</strong> : float | None</p>
<blockquote>
<div><p>The bandwidth of the multitaper windowing function in Hz.
Only used in &#8216;spectrum_fit&#8217; mode.</p>
</div></blockquote>
<p><strong>p_value</strong> : float</p>
<blockquote>
<div><p>p-value to use in F-test thresholding to determine significant
sinusoidal components to remove when method=&#8217;spectrum_fit&#8217; and
freqs=None. Note that this will be Bonferroni corrected for the
number of frequencies, so large p-values may be justified.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>raw</strong> : instance of Raw</p>
<blockquote class="last">
<div><p>The raw instance with filtered data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.io.Raw.html#mne.io.Raw.filter" title="mne.io.Raw.filter"><tt class="xref py py-obj docutils literal"><span class="pre">mne.io.Raw.filter</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<p>For details, see <a class="reference internal" href="mne.filter.notch_filter.html#mne.filter.notch_filter" title="mne.filter.notch_filter"><tt class="xref py py-func docutils literal"><span class="pre">mne.filter.notch_filter()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.pick_channels">
<tt class="descname">pick_channels</tt><big>(</big><em>ch_names</em>, <em>copy=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.pick_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick some channels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_names</strong> : list</p>
<blockquote>
<div><p>The list of channels to select.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>This parameter has been deprecated and will be removed in 0.13.
Use inst.copy() instead.
Whether to return a new instance or modify in place.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.io.RawArray.drop_channels" title="mne.io.RawArray.drop_channels"><tt class="xref py py-obj docutils literal"><span class="pre">drop_channels</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.pick_types">
<tt class="descname">pick_types</tt><big>(</big><em>meg=True</em>, <em>eeg=False</em>, <em>stim=False</em>, <em>eog=False</em>, <em>ecg=False</em>, <em>emg=False</em>, <em>ref_meg='auto'</em>, <em>misc=False</em>, <em>resp=False</em>, <em>chpi=False</em>, <em>exci=False</em>, <em>ias=False</em>, <em>syst=False</em>, <em>seeg=False</em>, <em>bio=False</em>, <em>ecog=False</em>, <em>include=[]</em>, <em>exclude='bads'</em>, <em>selection=None</em>, <em>copy=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.pick_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick some channels by type and names</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>meg</strong> : bool | str</p>
<blockquote>
<div><p>If True include all MEG channels. If False include None
If string it can be &#8216;mag&#8217;, &#8216;grad&#8217;, &#8216;planar1&#8217; or &#8216;planar2&#8217; to select
only magnetometers, all gradiometers, or a specific type of
gradiometer.</p>
</div></blockquote>
<p><strong>eeg</strong> : bool</p>
<blockquote>
<div><p>If True include EEG channels.</p>
</div></blockquote>
<p><strong>stim</strong> : bool</p>
<blockquote>
<div><p>If True include stimulus channels.</p>
</div></blockquote>
<p><strong>eog</strong> : bool</p>
<blockquote>
<div><p>If True include EOG channels.</p>
</div></blockquote>
<p><strong>ecg</strong> : bool</p>
<blockquote>
<div><p>If True include ECG channels.</p>
</div></blockquote>
<p><strong>emg</strong> : bool</p>
<blockquote>
<div><p>If True include EMG channels.</p>
</div></blockquote>
<p><strong>ref_meg: bool | str</strong> :</p>
<blockquote>
<div><p>If True include CTF / 4D reference channels. If &#8216;auto&#8217;, the
reference channels are only included if compensations are present.</p>
</div></blockquote>
<p><strong>misc</strong> : bool</p>
<blockquote>
<div><p>If True include miscellaneous analog channels.</p>
</div></blockquote>
<p><strong>resp</strong> : bool</p>
<blockquote>
<div><p>If True include response-trigger channel. For some MEG systems this
is separate from the stim channel.</p>
</div></blockquote>
<p><strong>chpi</strong> : bool</p>
<blockquote>
<div><p>If True include continuous HPI coil channels.</p>
</div></blockquote>
<p><strong>exci</strong> : bool</p>
<blockquote>
<div><p>Flux excitation channel used to be a stimulus channel.</p>
</div></blockquote>
<p><strong>ias</strong> : bool</p>
<blockquote>
<div><p>Internal Active Shielding data (maybe on Triux only).</p>
</div></blockquote>
<p><strong>syst</strong> : bool</p>
<blockquote>
<div><p>System status channel information (on Triux systems only).</p>
</div></blockquote>
<p><strong>seeg</strong> : bool</p>
<blockquote>
<div><p>Stereotactic EEG channels.</p>
</div></blockquote>
<p><strong>bio</strong> : bool</p>
<blockquote>
<div><p>Bio channels.</p>
</div></blockquote>
<p><strong>ecog</strong> : bool</p>
<blockquote>
<div><p>Electrocorticography channels.</p>
</div></blockquote>
<p><strong>include</strong> : list of string</p>
<blockquote>
<div><p>List of additional channels to include. If empty do not include
any.</p>
</div></blockquote>
<p><strong>exclude</strong> : list of string | str</p>
<blockquote>
<div><p>List of channels to exclude. If &#8216;bads&#8217; (default), exclude channels
in <tt class="docutils literal"><span class="pre">info['bads']</span></tt>.</p>
</div></blockquote>
<p><strong>selection</strong> : list of string</p>
<blockquote>
<div><p>Restrict sensor channels (MEG, EEG) to this list of channel names.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>This parameter has been deprecated and will be removed in 0.13.
Use inst.copy() instead.
Whether to return a new instance or modify in place.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.plot">
<tt class="descname">plot</tt><big>(</big><em>events=None</em>, <em>duration=10.0</em>, <em>start=0.0</em>, <em>n_channels=20</em>, <em>bgcolor='w'</em>, <em>color=None</em>, <em>bad_color=(0.8</em>, <em>0.8</em>, <em>0.8)</em>, <em>event_color='cyan'</em>, <em>scalings=None</em>, <em>remove_dc=True</em>, <em>order='type'</em>, <em>show_options=False</em>, <em>title=None</em>, <em>show=True</em>, <em>block=False</em>, <em>highpass=None</em>, <em>lowpass=None</em>, <em>filtorder=4</em>, <em>clipping=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot raw data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>events</strong> : array | None</p>
<blockquote>
<div><p>Events to show with vertical bars.</p>
</div></blockquote>
<p><strong>duration</strong> : float</p>
<blockquote>
<div><p>Time window (sec) to plot in a given time.</p>
</div></blockquote>
<p><strong>start</strong> : float</p>
<blockquote>
<div><p>Initial time to show (can be changed dynamically once plotted).</p>
</div></blockquote>
<p><strong>n_channels</strong> : int</p>
<blockquote>
<div><p>Number of channels to plot at once. Defaults to 20.</p>
</div></blockquote>
<p><strong>bgcolor</strong> : color object</p>
<blockquote>
<div><p>Color of the background.</p>
</div></blockquote>
<p><strong>color</strong> : dict | color object | None</p>
<blockquote>
<div><p>Color for the data traces. If None, defaults to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">dict</span><span class="p">(</span><span class="n">mag</span><span class="o">=</span><span class="s1">&#39;darkblue&#39;</span><span class="p">,</span> <span class="n">grad</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">eeg</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">eog</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ecg</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span>
     <span class="n">emg</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ref_meg</span><span class="o">=</span><span class="s1">&#39;steelblue&#39;</span><span class="p">,</span> <span class="n">misc</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
     <span class="n">resp</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">chpi</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>bad_color</strong> : color object</p>
<blockquote>
<div><p>Color to make bad channels.</p>
</div></blockquote>
<p><strong>event_color</strong> : color object</p>
<blockquote>
<div><p>Color to use for events.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | None</p>
<blockquote>
<div><p>Scaling factors for the traces. If any fields in scalings are
&#8216;auto&#8217;, the scaling factor is set to match the 99.5th percentile of
a subset of the corresponding data. If scalings == &#8216;auto&#8217;, all
scalings fields are set to &#8216;auto&#8217;. If any fields are &#8216;auto&#8217; and
data is not preloaded, a subset of times up to 100mb will be
loaded. If None, defaults to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">dict</span><span class="p">(</span><span class="n">mag</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">grad</span><span class="o">=</span><span class="mf">4e-11</span><span class="p">,</span> <span class="n">eeg</span><span class="o">=</span><span class="mf">20e-6</span><span class="p">,</span> <span class="n">eog</span><span class="o">=</span><span class="mf">150e-6</span><span class="p">,</span> <span class="n">ecg</span><span class="o">=</span><span class="mf">5e-4</span><span class="p">,</span>
     <span class="n">emg</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">ref_meg</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">misc</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
     <span class="n">resp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">chpi</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>remove_dc</strong> : bool</p>
<blockquote>
<div><p>If True remove DC component when plotting data.</p>
</div></blockquote>
<p><strong>order</strong> : &#8216;type&#8217; | &#8216;original&#8217; | array</p>
<blockquote>
<div><p>Order in which to plot data. &#8216;type&#8217; groups by channel type,
&#8216;original&#8217; plots in the order of ch_names, array gives the
indices to use in plotting.</p>
</div></blockquote>
<p><strong>show_options</strong> : bool</p>
<blockquote>
<div><p>If True, a dialog for options related to projection is shown.</p>
</div></blockquote>
<p><strong>title</strong> : str | None</p>
<blockquote>
<div><p>The title of the window. If None, and either the filename of the
raw object or &#8216;&lt;unknown&gt;&#8217; will be displayed as title.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figures if True</p>
</div></blockquote>
<p><strong>block</strong> : bool</p>
<blockquote>
<div><p>Whether to halt program execution until the figure is closed.
Useful for setting bad channels on the fly (click on line).
May not work on all systems / platforms.</p>
</div></blockquote>
<p><strong>highpass</strong> : float | None</p>
<blockquote>
<div><p>Highpass to apply when displaying data.</p>
</div></blockquote>
<p><strong>lowpass</strong> : float | None</p>
<blockquote>
<div><p>Lowpass to apply when displaying data.</p>
</div></blockquote>
<p><strong>filtorder</strong> : int</p>
<blockquote>
<div><p>Filtering order. Note that for efficiency and simplicity,
filtering during plotting uses forward-backward IIR filtering,
so the effective filter order will be twice <tt class="docutils literal"><span class="pre">filtorder</span></tt>.
Filtering the lines for display may also produce some edge
artifacts (at the left and right edges) of the signals
during display. Filtering requires scipy &gt;= 0.10.</p>
</div></blockquote>
<p><strong>clipping</strong> : str | None</p>
<blockquote>
<div><p>If None, channels are allowed to exceed their designated bounds in
the plot. If &#8220;clamp&#8221;, then values are clamped to the appropriate
range for display, creating step-like artifacts. If &#8220;transparent&#8221;,
then excessive values are not shown, creating gaps in the traces.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Instance of matplotlib.figure.Figure</p>
<blockquote class="last">
<div><p>Raw traces.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The arrow keys (up/down/left/right) can typically be used to navigate
between channels and time ranges, but this depends on the backend
matplotlib is configured to use (e.g., mpl.use(&#8216;TkAgg&#8217;) should work).
The scaling can be adjusted with - and + (or =) keys. The viewport
dimensions can be adjusted with page up/page down and home/end keys.
Full screen mode can be to toggled with f11 key. To mark or un-mark a
channel as bad, click on the rather flat segments of a channel&#8217;s time
series. The changes will be reflected immediately in the raw object&#8217;s
<tt class="docutils literal"><span class="pre">raw.info['bads']</span></tt> entry.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.plot_projs_topomap">
<tt class="descname">plot_projs_topomap</tt><big>(</big><em>ch_type=None</em>, <em>layout=None</em>, <em>axes=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.plot_projs_topomap" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot SSP vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_type</strong> : &#8216;mag&#8217; | &#8216;grad&#8217; | &#8216;planar1&#8217; | &#8216;planar2&#8217; | &#8216;eeg&#8217; | None | List</p>
<blockquote>
<div><p>The channel type to plot. For &#8216;grad&#8217;, the gradiometers are collec-
ted in pairs and the RMS for each pair is plotted. If None
(default), it will return all channel types present. If a list of
ch_types is provided, it will return multiple figures.</p>
</div></blockquote>
<p><strong>layout</strong> : None | Layout | List of Layouts</p>
<blockquote>
<div><p>Layout instance specifying sensor positions (does not need to
be specified for Neuromag data). If possible, the correct
layout file is inferred from the data; if no appropriate layout
file was found, the layout is automatically generated from the
sensor locations. Or a list of Layout if projections
are from different sensor types.</p>
</div></blockquote>
<p><strong>axes</strong> : instance of Axes | list | None</p>
<blockquote>
<div><p>The axes to plot to. If list, the list must be a list of Axes of
the same length as the number of projectors. If instance of Axes,
there must be only one projector. Defaults to None.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote class="last">
<div><p>Figure distributing one image per channel across sensor topography.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.plot_psd">
<tt class="descname">plot_psd</tt><big>(</big><em>tmin=0.0</em>, <em>tmax=60.0</em>, <em>fmin=0</em>, <em>fmax=inf</em>, <em>proj=False</em>, <em>n_fft=2048</em>, <em>picks=None</em>, <em>ax=None</em>, <em>color='black'</em>, <em>area_mode='std'</em>, <em>area_alpha=0.33</em>, <em>n_overlap=0</em>, <em>dB=True</em>, <em>show=True</em>, <em>n_jobs=1</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.plot_psd" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the power spectral density across channels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tmin</strong> : float</p>
<blockquote>
<div><p>Start time for calculations.</p>
</div></blockquote>
<p><strong>tmax</strong> : float</p>
<blockquote>
<div><p>End time for calculations.</p>
</div></blockquote>
<p><strong>fmin</strong> : float</p>
<blockquote>
<div><p>Start frequency to consider.</p>
</div></blockquote>
<p><strong>fmax</strong> : float</p>
<blockquote>
<div><p>End frequency to consider.</p>
</div></blockquote>
<p><strong>proj</strong> : bool</p>
<blockquote>
<div><p>Apply projection.</p>
</div></blockquote>
<p><strong>n_fft</strong> : int</p>
<blockquote>
<div><p>Number of points to use in Welch FFT calculations.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>List of channels to use. Cannot be None if <cite>ax</cite> is supplied. If
both <cite>picks</cite> and <cite>ax</cite> are None, separate subplots will be created
for each standard channel type (<cite>mag</cite>, <cite>grad</cite>, and <cite>eeg</cite>).</p>
</div></blockquote>
<p><strong>ax</strong> : instance of matplotlib Axes | None</p>
<blockquote>
<div><p>Axes to plot into. If None, axes will be created.</p>
</div></blockquote>
<p><strong>color</strong> : str | tuple</p>
<blockquote>
<div><p>A matplotlib-compatible color to use.</p>
</div></blockquote>
<p><strong>area_mode</strong> : str | None</p>
<blockquote>
<div><p>How to plot area. If &#8216;std&#8217;, the mean +/- 1 STD (across channels)
will be plotted. If &#8216;range&#8217;, the min and max (across channels)
will be plotted. Bad channels will be excluded from these
calculations. If None, no area will be plotted.</p>
</div></blockquote>
<p><strong>area_alpha</strong> : float</p>
<blockquote>
<div><p>Alpha for the area.</p>
</div></blockquote>
<p><strong>n_overlap</strong> : int</p>
<blockquote>
<div><p>The number of points of overlap between blocks. The default value
is 0 (no overlap).</p>
</div></blockquote>
<p><strong>dB</strong> : bool</p>
<blockquote>
<div><p>If True, transform data to decibels.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Call pyplot.show() at the end.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int</p>
<blockquote>
<div><p>Number of jobs to run in parallel.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote class="last">
<div><p>Figure with frequency spectra of the data channels.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.plot_psd_topo">
<tt class="descname">plot_psd_topo</tt><big>(</big><em>tmin=0.0</em>, <em>tmax=None</em>, <em>fmin=0</em>, <em>fmax=100</em>, <em>proj=False</em>, <em>n_fft=2048</em>, <em>n_overlap=0</em>, <em>layout=None</em>, <em>color='w'</em>, <em>fig_facecolor='k'</em>, <em>axis_facecolor='k'</em>, <em>dB=True</em>, <em>show=True</em>, <em>n_jobs=1</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.plot_psd_topo" title="Permalink to this definition">¶</a></dt>
<dd><p>Function for plotting channel wise frequency spectra as topography.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tmin</strong> : float</p>
<blockquote>
<div><p>Start time for calculations. Defaults to zero.</p>
</div></blockquote>
<p><strong>tmax</strong> : float | None</p>
<blockquote>
<div><p>End time for calculations. If None (default), the end of data is
used.</p>
</div></blockquote>
<p><strong>fmin</strong> : float</p>
<blockquote>
<div><p>Start frequency to consider. Defaults to zero.</p>
</div></blockquote>
<p><strong>fmax</strong> : float</p>
<blockquote>
<div><p>End frequency to consider. Defaults to 100.</p>
</div></blockquote>
<p><strong>proj</strong> : bool</p>
<blockquote>
<div><p>Apply projection. Defaults to False.</p>
</div></blockquote>
<p><strong>n_fft</strong> : int</p>
<blockquote>
<div><p>Number of points to use in Welch FFT calculations. Defaults to
2048.</p>
</div></blockquote>
<p><strong>n_overlap</strong> : int</p>
<blockquote>
<div><p>The number of points of overlap between blocks. Defaults to 0
(no overlap).</p>
</div></blockquote>
<p><strong>layout</strong> : instance of Layout | None</p>
<blockquote>
<div><p>Layout instance specifying sensor positions (does not need to
be specified for Neuromag data). If None (default), the correct
layout is inferred from the data.</p>
</div></blockquote>
<p><strong>color</strong> : str | tuple</p>
<blockquote>
<div><p>A matplotlib-compatible color to use for the curves. Defaults to
white.</p>
</div></blockquote>
<p><strong>fig_facecolor</strong> : str | tuple</p>
<blockquote>
<div><p>A matplotlib-compatible color to use for the figure background.
Defaults to black.</p>
</div></blockquote>
<p><strong>axis_facecolor</strong> : str | tuple</p>
<blockquote>
<div><p>A matplotlib-compatible color to use for the axis background.
Defaults to black.</p>
</div></blockquote>
<p><strong>dB</strong> : bool</p>
<blockquote>
<div><p>If True, transform data to decibels. Defaults to True.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figure if True. Defaults to True.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int</p>
<blockquote>
<div><p>Number of jobs to run in parallel. Defaults to 1.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote class="last">
<div><p>Figure distributing one image per channel across sensor topography.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.plot_sensors">
<tt class="descname">plot_sensors</tt><big>(</big><em>kind='topomap'</em>, <em>ch_type=None</em>, <em>title=None</em>, <em>show_names=False</em>, <em>show=True</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.plot_sensors" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot sensors positions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kind</strong> : str</p>
<blockquote>
<div><p>Whether to plot the sensors as 3d or as topomap. Available options
&#8216;topomap&#8217;, &#8216;3d&#8217;. Defaults to &#8216;topomap&#8217;.</p>
</div></blockquote>
<p><strong>ch_type</strong> : &#8216;mag&#8217; | &#8216;grad&#8217; | &#8216;eeg&#8217; | &#8216;seeg&#8217; | &#8216;ecog&#8217; | None</p>
<blockquote>
<div><p>The channel type to plot. If None, then channels are chosen in the
order given above.</p>
</div></blockquote>
<p><strong>title</strong> : str | None</p>
<blockquote>
<div><p>Title for the figure. If None (default), equals to
<tt class="docutils literal"><span class="pre">'Sensor</span> <span class="pre">positions</span> <span class="pre">(%s)'</span> <span class="pre">%</span> <span class="pre">ch_type</span></tt>.</p>
</div></blockquote>
<p><strong>show_names</strong> : bool</p>
<blockquote>
<div><p>Whether to display all channel names. Defaults to False.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figure if True. Defaults to True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote class="last">
<div><p>Figure containing the sensor topography.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.viz.plot_layout.html#mne.viz.plot_layout" title="mne.viz.plot_layout"><tt class="xref py py-obj docutils literal"><span class="pre">mne.viz.plot_layout</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<p>This function plots the sensor locations from the info structure using
matplotlib. For drawing the sensors using mayavi see
<a class="reference internal" href="mne.viz.plot_trans.html#mne.viz.plot_trans" title="mne.viz.plot_trans"><tt class="xref py py-func docutils literal"><span class="pre">mne.viz.plot_trans()</span></tt></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.12.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.rename_channels">
<tt class="descname">rename_channels</tt><big>(</big><em>mapping</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.rename_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mapping</strong> : dict | callable</p>
<blockquote class="last">
<div><p>a dictionary mapping the old channel to a new channel name
e.g. {&#8216;EEG061&#8217; : &#8216;EEG161&#8217;}. Can also be a callable function
that takes and returns a string (new in version 0.10.0).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.resample">
<tt class="descname">resample</tt><big>(</big><em>sfreq</em>, <em>npad=None</em>, <em>window='boxcar'</em>, <em>stim_picks=None</em>, <em>n_jobs=1</em>, <em>events=None</em>, <em>copy=None</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample all channels.</p>
<p>The Raw object has to have the data loaded e.g. with <tt class="docutils literal"><span class="pre">preload=True</span></tt>
or <tt class="docutils literal"><span class="pre">self.load_data()</span></tt>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>The intended purpose of this function is primarily to
speed up computations (e.g., projection calculation) when
precise timing of events is not required, as downsampling
raw data effectively jitters trigger timings. It is
generally recommended not to epoch downsampled data,
but instead epoch and then downsample, as epoching
downsampled data jitters triggers.
For more, see
<a class="reference external" href="https://gist.github.com/Eric89GXL/01642cb3789992fbca59">this illustrative gist</a>.</p>
<p class="last">If resampling the continuous data is desired, it is
recommended to construct events using the original data.
The event onsets can be jointly resampled with the raw
data using the &#8216;events&#8217; parameter.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sfreq</strong> : float</p>
<blockquote>
<div><p>New sample rate to use.</p>
</div></blockquote>
<p><strong>npad</strong> : int | str</p>
<blockquote>
<div><p>Amount to pad the start and end of the data.
Can also be &#8220;auto&#8221; to use a padding that will result in
a power-of-two size (can be much faster).</p>
</div></blockquote>
<p><strong>window</strong> : string or tuple</p>
<blockquote>
<div><p>Frequency-domain window to use in resampling.
See <tt class="xref py py-func docutils literal"><span class="pre">scipy.signal.resample()</span></tt>.</p>
</div></blockquote>
<p><strong>stim_picks</strong> : array of int | None</p>
<blockquote>
<div><p>Stim channels. These channels are simply subsampled or
supersampled (without applying any filtering). This reduces
resampling artifacts in stim channels, but may lead to missing
triggers. If None, stim channels are automatically chosen using
<a class="reference internal" href="mne.pick_types.html#mne.pick_types" title="mne.pick_types"><tt class="xref py py-func docutils literal"><span class="pre">mne.pick_types()</span></tt></a>.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int | str</p>
<blockquote>
<div><p>Number of jobs to run in parallel. Can be &#8216;cuda&#8217; if scikits.cuda
is installed properly and CUDA is initialized.</p>
</div></blockquote>
<p><strong>events</strong> : 2D array, shape (n_events, 3) | None</p>
<blockquote>
<div><p>An optional event matrix. When specified, the onsets of the events
are resampled jointly with the data.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>Whether to operate on a copy of the data (True) or modify data
in-place (False). Defaults to False.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>raw</strong> : instance of Raw</p>
<blockquote class="last">
<div><p>The resampled version of the raw object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.io.Raw.html#mne.io.Raw.filter" title="mne.io.Raw.filter"><tt class="xref py py-obj docutils literal"><span class="pre">mne.io.Raw.filter</span></tt></a>, <a class="reference internal" href="mne.Epochs.html#mne.Epochs.resample" title="mne.Epochs.resample"><tt class="xref py py-obj docutils literal"><span class="pre">mne.Epochs.resample</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<p>For some data, it may be more accurate to use <tt class="docutils literal"><span class="pre">npad=0</span></tt> to reduce
artifacts. This is dataset dependent &#8211; check your data!</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.save">
<tt class="descname">save</tt><big>(</big><em>fname</em>, <em>picks=None</em>, <em>tmin=0</em>, <em>tmax=None</em>, <em>buffer_size_sec=10</em>, <em>drop_small_buffer=False</em>, <em>proj=False</em>, <em>fmt='single'</em>, <em>overwrite=False</em>, <em>split_size='2GB'</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save raw data to file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fname</strong> : string</p>
<blockquote>
<div><p>File name of the new dataset. This has to be a new filename
unless data have been preloaded. Filenames should end with
raw.fif, raw.fif.gz, raw_sss.fif, raw_sss.fif.gz, raw_tsss.fif
or raw_tsss.fif.gz.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>Indices of channels to include. If None all channels are kept.</p>
</div></blockquote>
<p><strong>tmin</strong> : float | None</p>
<blockquote>
<div><p>Time in seconds of first sample to save. If None first sample
is used.</p>
</div></blockquote>
<p><strong>tmax</strong> : float | None</p>
<blockquote>
<div><p>Time in seconds of last sample to save. If None last sample
is used.</p>
</div></blockquote>
<p><strong>buffer_size_sec</strong> : float | None</p>
<blockquote>
<div><p>Size of data chunks in seconds. If None, the buffer size of
the original file is used.</p>
</div></blockquote>
<p><strong>drop_small_buffer</strong> : bool</p>
<blockquote>
<div><p>Drop or not the last buffer. It is required by maxfilter (SSS)
that only accepts raw files with buffers of the same size.</p>
</div></blockquote>
<p><strong>proj</strong> : bool</p>
<blockquote>
<div><p>If True the data is saved with the projections applied (active).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <tt class="docutils literal"><span class="pre">apply_proj()</span></tt> was used to apply the projections,
the projectons will be active even if <tt class="docutils literal"><span class="pre">proj</span></tt> is False.</p>
</div>
</div></blockquote>
<p><strong>fmt</strong> : str</p>
<blockquote>
<div><p>Format to use to save raw data. Valid options are &#8216;double&#8217;,
&#8216;single&#8217;, &#8216;int&#8217;, and &#8216;short&#8217; for 64- or 32-bit float, or 32- or
16-bit integers, respectively. It is <strong>strongly</strong> recommended to
use &#8216;single&#8217;, as this is backward-compatible, and is standard for
maintaining precision. Note that using &#8216;short&#8217; or &#8216;int&#8217; may result
in loss of precision, complex data cannot be saved as &#8216;short&#8217;,
and neither complex data types nor real data stored as &#8216;double&#8217;
can be loaded with the MNE command-line tools. See raw.orig_format
to determine the format the original data were stored in.</p>
</div></blockquote>
<p><strong>overwrite</strong> : bool</p>
<blockquote>
<div><p>If True, the destination file (if it exists) will be overwritten.
If False (default), an error will be raised if the file exists.</p>
</div></blockquote>
<p><strong>split_size</strong> : string | int</p>
<blockquote>
<div><p>Large raw files are automatically split into multiple pieces. This
parameter specifies the maximum size of each piece. If the
parameter is an integer, it specifies the size in Bytes. It is
also possible to pass a human-readable string, e.g., 100MB.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Due to FIFF file limitations, the maximum split
size is 2GB.</p>
</div>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If Raw is a concatenation of several raw files, <strong>be warned</strong> that
only the measurement information from the first raw file is stored.
This likely means that certain operations with external tools may not
work properly on a saved concatenated file (e.g., probably some
or all forms of SSS). It is recommended not to concatenate and
then save raw files for this reason.</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.set_channel_types">
<tt class="descname">set_channel_types</tt><big>(</big><em>mapping</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.set_channel_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the sensor type of channels.</p>
<dl class="docutils">
<dt>Note: The following sensor types are accepted:</dt>
<dd>ecg, eeg, emg, eog, exci, ias, misc, resp, seeg, stim, syst, ecog</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mapping</strong> : dict</p>
<blockquote class="last">
<div><p>a dictionary mapping a channel to a sensor type (str)
{&#8216;EEG061&#8217;: &#8216;eog&#8217;}.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.set_montage">
<tt class="descname">set_montage</tt><big>(</big><em>montage</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.set_montage" title="Permalink to this definition">¶</a></dt>
<dd><p>Set EEG sensor configuration</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>montage</strong> : instance of Montage or DigMontage</p>
<blockquote>
<div><p>The montage to use.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Operates in place.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.time_as_index">
<tt class="descname">time_as_index</tt><big>(</big><em>times</em>, <em>use_first_samp=None</em>, <em>use_rounding=False</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.time_as_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert time to indices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>times</strong> : list-like | float | int</p>
<blockquote>
<div><p>List of numbers or a number representing points in time.</p>
</div></blockquote>
<p><strong>use_first_samp</strong> : boolean</p>
<blockquote>
<div><p>This is deprecated and will be removed in 0.13.
If True, time is treated as relative to the session onset, else
as relative to the recording onset. Default is False.</p>
</div></blockquote>
<p><strong>use_rounding</strong> : boolean</p>
<blockquote>
<div><p>If True, use rounding (instead of truncation) when converting
times to indices. This can help avoid non-unique indices.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>index</strong> : ndarray</p>
<blockquote class="last">
<div><p>Indices corresponding to the times supplied.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mne.io.RawArray.times">
<tt class="descname">times</tt><a class="headerlink" href="#mne.io.RawArray.times" title="Permalink to this definition">¶</a></dt>
<dd><p>Time points</p>
</dd></dl>

<dl class="method">
<dt id="mne.io.RawArray.to_data_frame">
<tt class="descname">to_data_frame</tt><big>(</big><em>picks=None</em>, <em>index=None</em>, <em>scale_time=1000.0</em>, <em>scalings=None</em>, <em>copy=True</em>, <em>start=None</em>, <em>stop=None</em><big>)</big><a class="headerlink" href="#mne.io.RawArray.to_data_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Export data in tabular structure as a pandas DataFrame.</p>
<p>Columns and indices will depend on the object being converted.
Generally this will include as much relevant information as
possible for the data type being converted. This makes it easy
to convert data for use in packages that utilize dataframes,
such as statsmodels or seaborn.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>If None only MEG and EEG channels are kept
otherwise the channels indices in picks are kept.</p>
</div></blockquote>
<p><strong>index</strong> : tuple of str | None</p>
<blockquote>
<div><p>Column to be used as index for the data. Valid string options
are &#8216;epoch&#8217;, &#8216;time&#8217; and &#8216;condition&#8217;. If None, all three info
columns will be included in the table as categorial data.</p>
</div></blockquote>
<p><strong>scale_time</strong> : float</p>
<blockquote>
<div><p>Scaling to be applied to time units.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | None</p>
<blockquote>
<div><p>Scaling to be applied to the channels picked. If None, defaults to
<tt class="docutils literal"><span class="pre">scalings=dict(eeg=1e6,</span> <span class="pre">grad=1e13,</span> <span class="pre">mag=1e15,</span> <span class="pre">misc=1.0)</span></tt>.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>If true, data will be copied. Else data may be modified in place.</p>
</div></blockquote>
<p><strong>start</strong> : int | None</p>
<blockquote>
<div><p>If it is a Raw object, this defines a starting index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</div></blockquote>
<p><strong>stop</strong> : int | None</p>
<blockquote>
<div><p>If it is a Raw object, this defines a stop index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>df</strong> : instance of pandas.core.DataFrame</p>
<blockquote class="last">
<div><p>A dataframe suitable for usage with other
statistical/plotting/analysis packages. Column/Index values will
depend on the object type being converted, but should be
human-readable.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


    </div>
    
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2012-2016, MNE Developers. Last updated on 2016-05-11.<br/>
    </p>
  </div>
</footer>
  </body>
</html>