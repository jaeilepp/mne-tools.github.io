<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mne.Evoked &mdash; MNE 0.12.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootswatch-3.3.4/flatly/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.12.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.4/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="MNE 0.12.0 documentation" href="../index.html" />
    <link rel="up" title="Python API Reference" href="../python_reference.html" />
    <link rel="next" title="mne.SourceSpaces" href="mne.SourceSpaces.html" />
    <link rel="prev" title="mne.Epochs" href="mne.Epochs.html" />

<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,400,700' rel='stylesheet' type='text/css'>


    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37225609-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>



    <script type="text/javascript">
    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);
    js.id=id;js.src="http://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
    </script>



    <script type="text/javascript">
    (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    </script>


  </head>
  <body>





  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><img src="../_static/mne_logo_small.png">
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.12.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../getting_started.html">Get started</a></li>
                <li><a href="../tutorials.html">Tutorials</a></li>
                <li><a href="../auto_examples/index.html">Gallery</a></li>
                <li><a href="../python_reference.html">API</a></li>
                <li><a href="../manual/index.html">Manual</a></li>
                <li><a href="../faq.html">FAQ</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contribute to MNE</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../python_reference.html">Python API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../manual/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whats_new.html">What&#8217;s new</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cite.html">How to cite MNE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">Related publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cited.html">Publications from MNE users</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">mne.Evoked</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/mne_logo_small.png" alt="Logo"/>
            </a></p><ul>
<li><a class="reference internal" href="#">mne.Evoked</a></li>
</ul>

  <li>
    <a href="mne.Epochs.html" title="Previous Chapter: mne.Epochs"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; mne.Epochs</span>
    </a>
  </li>
  <li>
    <a href="mne.SourceSpaces.html" title="Next Chapter: mne.SourceSpaces"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">mne.SourceSpaces &raquo;</span>
    </a>
  </li>
<form action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="col-md-12">
      
  <div class="section" id="mne-evoked">
<h1>mne.Evoked<a class="headerlink" href="#mne-evoked" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="mne.Evoked">
<em class="property">class </em><tt class="descclassname">mne.</tt><tt class="descname">Evoked</tt><big>(</big><em>fname</em>, <em>condition=None</em>, <em>baseline=None</em>, <em>proj=True</em>, <em>kind='average'</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.Evoked" title="Permalink to this definition">¶</a></dt>
<dd><p>Evoked data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fname</strong> : string</p>
<blockquote>
<div><p>Name of evoked/average FIF file to load.
If None no data is loaded.</p>
</div></blockquote>
<p><strong>condition</strong> : int, or str</p>
<blockquote>
<div><p>Dataset ID number (int) or comment/name (str). Optional if there is
only one data set in file.</p>
</div></blockquote>
<p><strong>baseline</strong> : tuple or list of length 2, or None</p>
<blockquote>
<div><p>The time interval to apply rescaling / baseline correction.
If None do not apply it. If baseline is (a, b)
the interval is between &#8220;a (s)&#8221; and &#8220;b (s)&#8221;.
If a is None the beginning of the data is used
and if b is None then b is set to the end of the interval.
If baseline is equal ot (None, None) all the time
interval is used. If None, no correction is applied.</p>
</div></blockquote>
<p><strong>proj</strong> : bool, optional</p>
<blockquote>
<div><p>Apply SSP projection vectors</p>
</div></blockquote>
<p><strong>kind</strong> : str</p>
<blockquote>
<div><p>Either &#8216;average&#8217; or &#8216;standard_error&#8217;. The type of data to read.
Only used if &#8216;condition&#8217; is a str.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><p class="first"><strong>info</strong> : dict</p>
<blockquote>
<div><p>Measurement info.</p>
</div></blockquote>
<p><strong>ch_names</strong> : list of string</p>
<blockquote>
<div><p>List of channels&#8217; names.</p>
</div></blockquote>
<p><strong>nave</strong> : int</p>
<blockquote>
<div><p>Number of averaged epochs.</p>
</div></blockquote>
<p><strong>kind</strong> : str</p>
<blockquote>
<div><p>Type of data, either average or standard_error.</p>
</div></blockquote>
<p><strong>first</strong> : int</p>
<blockquote>
<div><p>First time sample.</p>
</div></blockquote>
<p><strong>last</strong> : int</p>
<blockquote>
<div><p>Last time sample.</p>
</div></blockquote>
<p><strong>comment</strong> : string</p>
<blockquote>
<div><p>Comment on dataset. Can be the condition.</p>
</div></blockquote>
<p><strong>times</strong> : array</p>
<blockquote>
<div><p>Array of time instants in seconds.</p>
</div></blockquote>
<p><strong>data</strong> : array of shape (n_channels, n_times)</p>
<blockquote>
<div><p>Evoked response.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None.</p>
<blockquote class="last">
<div><p>See above.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Evoked objects contain a single condition only.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.add_channels" title="mne.Evoked.add_channels"><tt class="xref py py-obj docutils literal"><span class="pre">add_channels</span></tt></a>(add_list[,&nbsp;copy,&nbsp;force_update_info])</td>
<td>Append new channels to the instance.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.add_eeg_average_proj" title="mne.Evoked.add_eeg_average_proj"><tt class="xref py py-obj docutils literal"><span class="pre">add_eeg_average_proj</span></tt></a>()</td>
<td>Add an average EEG reference projector if one does not exist</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.add_proj" title="mne.Evoked.add_proj"><tt class="xref py py-obj docutils literal"><span class="pre">add_proj</span></tt></a>(projs[,&nbsp;remove_existing,&nbsp;verbose])</td>
<td>Add SSP projection vectors</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.animate_topomap" title="mne.Evoked.animate_topomap"><tt class="xref py py-obj docutils literal"><span class="pre">animate_topomap</span></tt></a>([ch_type,&nbsp;times,&nbsp;...])</td>
<td>Make animation of evoked data as topomap timeseries.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.apply_proj" title="mne.Evoked.apply_proj"><tt class="xref py py-obj docutils literal"><span class="pre">apply_proj</span></tt></a>()</td>
<td>Apply the signal space projection (SSP) operators to the data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.as_type" title="mne.Evoked.as_type"><tt class="xref py py-obj docutils literal"><span class="pre">as_type</span></tt></a>([ch_type,&nbsp;mode])</td>
<td>Compute virtual evoked using interpolated fields in mag/grad channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.copy" title="mne.Evoked.copy"><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt></a>()</td>
<td>Copy the instance of evoked</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.crop" title="mne.Evoked.crop"><tt class="xref py py-obj docutils literal"><span class="pre">crop</span></tt></a>([tmin,&nbsp;tmax,&nbsp;copy])</td>
<td>Crop data to a given time interval</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.del_proj" title="mne.Evoked.del_proj"><tt class="xref py py-obj docutils literal"><span class="pre">del_proj</span></tt></a>(idx)</td>
<td>Remove SSP projection vector</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.detrend" title="mne.Evoked.detrend"><tt class="xref py py-obj docutils literal"><span class="pre">detrend</span></tt></a>([order,&nbsp;picks])</td>
<td>Detrend data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.drop_channels" title="mne.Evoked.drop_channels"><tt class="xref py py-obj docutils literal"><span class="pre">drop_channels</span></tt></a>(ch_names[,&nbsp;copy])</td>
<td>Drop some channels</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.get_peak" title="mne.Evoked.get_peak"><tt class="xref py py-obj docutils literal"><span class="pre">get_peak</span></tt></a>([ch_type,&nbsp;tmin,&nbsp;tmax,&nbsp;mode,&nbsp;...])</td>
<td>Get location and latency of peak amplitude</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.interpolate_bads" title="mne.Evoked.interpolate_bads"><tt class="xref py py-obj docutils literal"><span class="pre">interpolate_bads</span></tt></a>([reset_bads,&nbsp;mode])</td>
<td>Interpolate bad MEG and EEG channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.pick_channels" title="mne.Evoked.pick_channels"><tt class="xref py py-obj docutils literal"><span class="pre">pick_channels</span></tt></a>(ch_names[,&nbsp;copy])</td>
<td>Pick some channels</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.pick_types" title="mne.Evoked.pick_types"><tt class="xref py py-obj docutils literal"><span class="pre">pick_types</span></tt></a>([meg,&nbsp;eeg,&nbsp;stim,&nbsp;eog,&nbsp;ecg,&nbsp;emg,&nbsp;...])</td>
<td>Pick some channels by type and names</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.plot" title="mne.Evoked.plot"><tt class="xref py py-obj docutils literal"><span class="pre">plot</span></tt></a>([picks,&nbsp;exclude,&nbsp;unit,&nbsp;show,&nbsp;ylim,&nbsp;...])</td>
<td>Plot evoked data using butterfly plots</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.plot_field" title="mne.Evoked.plot_field"><tt class="xref py py-obj docutils literal"><span class="pre">plot_field</span></tt></a>(surf_maps[,&nbsp;time,&nbsp;time_label,&nbsp;n_jobs])</td>
<td>Plot MEG/EEG fields on head surface and helmet in 3D</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.plot_image" title="mne.Evoked.plot_image"><tt class="xref py py-obj docutils literal"><span class="pre">plot_image</span></tt></a>([picks,&nbsp;exclude,&nbsp;unit,&nbsp;show,&nbsp;...])</td>
<td>Plot evoked data as images</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.plot_joint" title="mne.Evoked.plot_joint"><tt class="xref py py-obj docutils literal"><span class="pre">plot_joint</span></tt></a>([times,&nbsp;title,&nbsp;picks,&nbsp;exclude,&nbsp;...])</td>
<td>Plot evoked data as butterfly plots and add topomaps for selected time points.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.plot_projs_topomap" title="mne.Evoked.plot_projs_topomap"><tt class="xref py py-obj docutils literal"><span class="pre">plot_projs_topomap</span></tt></a>([ch_type,&nbsp;layout,&nbsp;axes])</td>
<td>Plot SSP vector</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.plot_sensors" title="mne.Evoked.plot_sensors"><tt class="xref py py-obj docutils literal"><span class="pre">plot_sensors</span></tt></a>([kind,&nbsp;ch_type,&nbsp;title,&nbsp;...])</td>
<td>Plot sensors positions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.plot_topo" title="mne.Evoked.plot_topo"><tt class="xref py py-obj docutils literal"><span class="pre">plot_topo</span></tt></a>([layout,&nbsp;layout_scale,&nbsp;color,&nbsp;...])</td>
<td>Plot 2D topography of evoked responses.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.plot_topomap" title="mne.Evoked.plot_topomap"><tt class="xref py py-obj docutils literal"><span class="pre">plot_topomap</span></tt></a>([times,&nbsp;ch_type,&nbsp;layout,&nbsp;vmin,&nbsp;...])</td>
<td>Plot topographic maps of specific time points</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.plot_white" title="mne.Evoked.plot_white"><tt class="xref py py-obj docutils literal"><span class="pre">plot_white</span></tt></a>(noise_cov[,&nbsp;show])</td>
<td>Plot whitened evoked response</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.rename_channels" title="mne.Evoked.rename_channels"><tt class="xref py py-obj docutils literal"><span class="pre">rename_channels</span></tt></a>(mapping)</td>
<td>Rename channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.resample" title="mne.Evoked.resample"><tt class="xref py py-obj docutils literal"><span class="pre">resample</span></tt></a>(sfreq[,&nbsp;npad,&nbsp;window])</td>
<td>Resample data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.save" title="mne.Evoked.save"><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt></a>(fname)</td>
<td>Save dataset to file.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.savgol_filter" title="mne.Evoked.savgol_filter"><tt class="xref py py-obj docutils literal"><span class="pre">savgol_filter</span></tt></a>(h_freq[,&nbsp;copy])</td>
<td>Filter the data using Savitzky-Golay polynomial method</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.set_channel_types" title="mne.Evoked.set_channel_types"><tt class="xref py py-obj docutils literal"><span class="pre">set_channel_types</span></tt></a>(mapping)</td>
<td>Define the sensor type of channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.set_montage" title="mne.Evoked.set_montage"><tt class="xref py py-obj docutils literal"><span class="pre">set_montage</span></tt></a>(montage[,&nbsp;verbose])</td>
<td>Set EEG sensor configuration</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.shift_time" title="mne.Evoked.shift_time"><tt class="xref py py-obj docutils literal"><span class="pre">shift_time</span></tt></a>(tshift[,&nbsp;relative])</td>
<td>Shift time scale in evoked data</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.time_as_index" title="mne.Evoked.time_as_index"><tt class="xref py py-obj docutils literal"><span class="pre">time_as_index</span></tt></a>(times[,&nbsp;use_rounding])</td>
<td>Convert time to indices</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.to_data_frame" title="mne.Evoked.to_data_frame"><tt class="xref py py-obj docutils literal"><span class="pre">to_data_frame</span></tt></a>([picks,&nbsp;index,&nbsp;scale_time,&nbsp;...])</td>
<td>Export data in tabular structure as a pandas DataFrame.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="mne.Evoked.__init__">
<tt class="descname">__init__</tt><big>(</big><em>fname</em>, <em>condition=None</em>, <em>baseline=None</em>, <em>proj=True</em>, <em>kind='average'</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.Evoked.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mne.Evoked.add_channels">
<tt class="descname">add_channels</tt><big>(</big><em>add_list</em>, <em>copy=None</em>, <em>force_update_info=False</em><big>)</big><a class="headerlink" href="#mne.Evoked.add_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Append new channels to the instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>add_list</strong> : list</p>
<blockquote>
<div><p>A list of objects to append to self. Must contain all the same
type as the current object</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>This parameter has been deprecated and will be removed in 0.13.
Use inst.copy() instead.
Whether to return a new instance or modify in place.</p>
</div></blockquote>
<p><strong>force_update_info</strong> : bool</p>
<blockquote>
<div><p>If True, force the info for objects to be appended to match the
values in <cite>self</cite>. This should generally only be used when adding
stim channels for which important metadata won&#8217;t be overwritten.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.12.</span></p>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.add_eeg_average_proj">
<tt class="descname">add_eeg_average_proj</tt><big>(</big><big>)</big><a class="headerlink" href="#mne.Evoked.add_eeg_average_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an average EEG reference projector if one does not exist</p>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.add_proj">
<tt class="descname">add_proj</tt><big>(</big><em>projs</em>, <em>remove_existing=False</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.Evoked.add_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Add SSP projection vectors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>projs</strong> : list</p>
<blockquote>
<div><p>List with projection vectors.</p>
</div></blockquote>
<p><strong>remove_existing</strong> : bool</p>
<blockquote>
<div><p>Remove the projection vectors currently in the file.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : instance of Raw | Epochs | Evoked</p>
<blockquote class="last">
<div><p>The data container.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.animate_topomap">
<tt class="descname">animate_topomap</tt><big>(</big><em>ch_type='mag'</em>, <em>times=None</em>, <em>frame_rate=None</em>, <em>butterfly=False</em>, <em>blit=True</em>, <em>show=True</em><big>)</big><a class="headerlink" href="#mne.Evoked.animate_topomap" title="Permalink to this definition">¶</a></dt>
<dd><p>Make animation of evoked data as topomap timeseries. Animation can
be paused/resumed with left mouse button. Left and right arrow keys can
be used to move backward or forward in time</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_type</strong> : str | None</p>
<blockquote>
<div><p>Channel type to plot. Accepted data types: &#8216;mag&#8217;, &#8216;grad&#8217;, &#8216;eeg&#8217;.
If None, first available channel type from (&#8216;mag&#8217;, &#8216;grad&#8217;, &#8216;eeg&#8217;)
is used. Defaults to None.</p>
</div></blockquote>
<p><strong>times</strong> : array of floats | None</p>
<blockquote>
<div><p>The time points to plot. If None, 10 evenly spaced samples are
calculated over the evoked time series. Defaults to None.</p>
</div></blockquote>
<p><strong>frame_rate</strong> : int | None</p>
<blockquote>
<div><p>Frame rate for the animation in Hz. If None,
frame rate = sfreq / 10. Defaults to None.</p>
</div></blockquote>
<p><strong>butterfly</strong> : bool</p>
<blockquote>
<div><p>Whether to plot the data as butterfly plot under the topomap.
Defaults to False.</p>
</div></blockquote>
<p><strong>blit</strong> : bool</p>
<blockquote>
<div><p>Whether to use blit to optimize drawing. In general, it is
recommended to use blit in combination with <tt class="docutils literal"><span class="pre">show=True</span></tt>. If you
intend to save the animation it is better to disable blit.
Defaults to True.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Whether to show the animation. Defaults to True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote>
<div><p>The figure.</p>
</div></blockquote>
<p><strong>anim</strong> : instance of matplotlib FuncAnimation</p>
<blockquote class="last">
<div><p>Animation of the topomap.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.12.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.apply_proj">
<tt class="descname">apply_proj</tt><big>(</big><big>)</big><a class="headerlink" href="#mne.Evoked.apply_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the signal space projection (SSP) operators to the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : instance of Raw | Epochs | Evoked</p>
<blockquote class="last">
<div><p>The instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Once the projectors have been applied, they can no longer be
removed. It is usually not recommended to apply the projectors at
too early stages, as they are applied automatically later on
(e.g. when computing inverse solutions).
Hint: using the copy method individual projection vectors
can be tested without affecting the original data.
With evoked data, consider the following example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">projs_a</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_proj</span><span class="p">(</span><span class="s1">&#39;proj_a.fif&#39;</span><span class="p">)</span>
<span class="n">projs_b</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_proj</span><span class="p">(</span><span class="s1">&#39;proj_b.fif&#39;</span><span class="p">)</span>
<span class="c1"># add the first, copy, apply and see ...</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">add_proj</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="c1"># add the second, copy, apply and see ...</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">add_proj</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="c1"># drop the first and see again</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">del_proj</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span>  <span class="c1"># finally keep both</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.as_type">
<tt class="descname">as_type</tt><big>(</big><em>ch_type='grad'</em>, <em>mode='fast'</em><big>)</big><a class="headerlink" href="#mne.Evoked.as_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute virtual evoked using interpolated fields in mag/grad
channels.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Using virtual evoked to compute inverse can yield
unexpected results. The virtual channels have <cite>&#8216;_virtual&#8217;</cite> appended
at the end of the names to emphasize that the data contained in
them are interpolated.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_type</strong> : str</p>
<blockquote>
<div><p>The destination channel type. It can be &#8216;mag&#8217; or &#8216;grad&#8217;.</p>
</div></blockquote>
<p><strong>mode</strong> : str</p>
<blockquote>
<div><p>Either <cite>&#8216;accurate&#8217;</cite> or <cite>&#8216;fast&#8217;</cite>, determines the quality of the
Legendre polynomial expansion used. <cite>&#8216;fast&#8217;</cite> should be sufficient
for most applications.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>evoked</strong> : instance of mne.Evoked</p>
<blockquote class="last">
<div><p>The transformed evoked object containing only virtual channels.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mne.Evoked.ch_names">
<tt class="descname">ch_names</tt><a class="headerlink" href="#mne.Evoked.ch_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Channel names</p>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#mne.Evoked.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the instance of evoked</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>evoked</strong> : instance of Evoked</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.crop">
<tt class="descname">crop</tt><big>(</big><em>tmin=None</em>, <em>tmax=None</em>, <em>copy=None</em><big>)</big><a class="headerlink" href="#mne.Evoked.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop data to a given time interval</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tmin</strong> : float | None</p>
<blockquote>
<div><p>Start time of selection in seconds.</p>
</div></blockquote>
<p><strong>tmax</strong> : float | None</p>
<blockquote>
<div><p>End time of selection in seconds.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote class="last">
<div><p>This parameter has been deprecated and will be removed in 0.13.
Use inst.copy() instead.
Whether to return a new instance or modify in place.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.del_proj">
<tt class="descname">del_proj</tt><big>(</big><em>idx</em><big>)</big><a class="headerlink" href="#mne.Evoked.del_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove SSP projection vector</p>
<dl class="docutils">
<dt>Note: The projection vector can only be removed if it is inactive</dt>
<dd>(has not been applied to the data).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>idx</strong> : int</p>
<blockquote>
<div><p>Index of the projector to remove.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>self</strong> : instance of Raw | Epochs | Evoked</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.detrend">
<tt class="descname">detrend</tt><big>(</big><em>order=1</em>, <em>picks=None</em><big>)</big><a class="headerlink" href="#mne.Evoked.detrend" title="Permalink to this definition">¶</a></dt>
<dd><p>Detrend data</p>
<p>This function operates in-place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>order</strong> : int</p>
<blockquote>
<div><p>Either 0 or 1, the order of the detrending. 0 is a constant
(DC) detrend, 1 is a linear detrend.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>If None only MEG, EEG, SEEG, and ECoG channels are detrended.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>evoked</strong> : instance of Evoked</p>
<blockquote class="last">
<div><p>The evoked instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.drop_channels">
<tt class="descname">drop_channels</tt><big>(</big><em>ch_names</em>, <em>copy=None</em><big>)</big><a class="headerlink" href="#mne.Evoked.drop_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop some channels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_names</strong> : list</p>
<blockquote>
<div><p>The list of channels to remove.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>This parameter has been deprecated and will be removed in 0.13.
Use inst.copy() instead.
Whether to return a new instance or modify in place.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.pick_channels.html#mne.pick_channels" title="mne.pick_channels"><tt class="xref py py-obj docutils literal"><span class="pre">pick_channels</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.get_peak">
<tt class="descname">get_peak</tt><big>(</big><em>ch_type=None</em>, <em>tmin=None</em>, <em>tmax=None</em>, <em>mode='abs'</em>, <em>time_as_index=False</em><big>)</big><a class="headerlink" href="#mne.Evoked.get_peak" title="Permalink to this definition">¶</a></dt>
<dd><p>Get location and latency of peak amplitude</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_type</strong> : {&#8216;mag&#8217;, &#8216;grad&#8217;, &#8216;eeg&#8217;, &#8216;seeg&#8217;, &#8216;ecog&#8217;, &#8216;misc&#8217;, None}</p>
<blockquote>
<div><p>The channel type to use. Defaults to None. If more than one sensor
Type is present in the data the channel type has to be explicitly
set.</p>
</div></blockquote>
<p><strong>tmin</strong> : float | None</p>
<blockquote>
<div><p>The minimum point in time to be considered for peak getting.
If None (default), the beginning of the data is used.</p>
</div></blockquote>
<p><strong>tmax</strong> : float | None</p>
<blockquote>
<div><p>The maximum point in time to be considered for peak getting.
If None (default), the end of the data is used.</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8216;pos&#8217;, &#8216;neg&#8217;, &#8216;abs&#8217;}</p>
<blockquote>
<div><p>How to deal with the sign of the data. If &#8216;pos&#8217; only positive
values will be considered. If &#8216;neg&#8217; only negative values will
be considered. If &#8216;abs&#8217; absolute values will be considered.
Defaults to &#8216;abs&#8217;.</p>
</div></blockquote>
<p><strong>time_as_index</strong> : bool</p>
<blockquote>
<div><p>Whether to return the time index instead of the latency in seconds.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ch_name</strong> : str</p>
<blockquote>
<div><p>The channel exhibiting the maximum response.</p>
</div></blockquote>
<p><strong>latency</strong> : float | int</p>
<blockquote class="last">
<div><p>The time point of the maximum response, either latency in seconds
or index.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.interpolate_bads">
<tt class="descname">interpolate_bads</tt><big>(</big><em>reset_bads=True</em>, <em>mode='accurate'</em><big>)</big><a class="headerlink" href="#mne.Evoked.interpolate_bads" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate bad MEG and EEG channels.</p>
<p>Operates in place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reset_bads</strong> : bool</p>
<blockquote>
<div><p>If True, remove the bads from info.</p>
</div></blockquote>
<p><strong>mode</strong> : str</p>
<blockquote>
<div><p>Either <cite>&#8216;accurate&#8217;</cite> or <cite>&#8216;fast&#8217;</cite>, determines the quality of the
Legendre polynomial expansion used for interpolation of MEG
channels.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.pick_channels">
<tt class="descname">pick_channels</tt><big>(</big><em>ch_names</em>, <em>copy=None</em><big>)</big><a class="headerlink" href="#mne.Evoked.pick_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick some channels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_names</strong> : list</p>
<blockquote>
<div><p>The list of channels to select.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>This parameter has been deprecated and will be removed in 0.13.
Use inst.copy() instead.
Whether to return a new instance or modify in place.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.Evoked.drop_channels" title="mne.Evoked.drop_channels"><tt class="xref py py-obj docutils literal"><span class="pre">drop_channels</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.pick_types">
<tt class="descname">pick_types</tt><big>(</big><em>meg=True</em>, <em>eeg=False</em>, <em>stim=False</em>, <em>eog=False</em>, <em>ecg=False</em>, <em>emg=False</em>, <em>ref_meg='auto'</em>, <em>misc=False</em>, <em>resp=False</em>, <em>chpi=False</em>, <em>exci=False</em>, <em>ias=False</em>, <em>syst=False</em>, <em>seeg=False</em>, <em>bio=False</em>, <em>ecog=False</em>, <em>include=[]</em>, <em>exclude='bads'</em>, <em>selection=None</em>, <em>copy=None</em><big>)</big><a class="headerlink" href="#mne.Evoked.pick_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick some channels by type and names</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>meg</strong> : bool | str</p>
<blockquote>
<div><p>If True include all MEG channels. If False include None
If string it can be &#8216;mag&#8217;, &#8216;grad&#8217;, &#8216;planar1&#8217; or &#8216;planar2&#8217; to select
only magnetometers, all gradiometers, or a specific type of
gradiometer.</p>
</div></blockquote>
<p><strong>eeg</strong> : bool</p>
<blockquote>
<div><p>If True include EEG channels.</p>
</div></blockquote>
<p><strong>stim</strong> : bool</p>
<blockquote>
<div><p>If True include stimulus channels.</p>
</div></blockquote>
<p><strong>eog</strong> : bool</p>
<blockquote>
<div><p>If True include EOG channels.</p>
</div></blockquote>
<p><strong>ecg</strong> : bool</p>
<blockquote>
<div><p>If True include ECG channels.</p>
</div></blockquote>
<p><strong>emg</strong> : bool</p>
<blockquote>
<div><p>If True include EMG channels.</p>
</div></blockquote>
<p><strong>ref_meg: bool | str</strong> :</p>
<blockquote>
<div><p>If True include CTF / 4D reference channels. If &#8216;auto&#8217;, the
reference channels are only included if compensations are present.</p>
</div></blockquote>
<p><strong>misc</strong> : bool</p>
<blockquote>
<div><p>If True include miscellaneous analog channels.</p>
</div></blockquote>
<p><strong>resp</strong> : bool</p>
<blockquote>
<div><p>If True include response-trigger channel. For some MEG systems this
is separate from the stim channel.</p>
</div></blockquote>
<p><strong>chpi</strong> : bool</p>
<blockquote>
<div><p>If True include continuous HPI coil channels.</p>
</div></blockquote>
<p><strong>exci</strong> : bool</p>
<blockquote>
<div><p>Flux excitation channel used to be a stimulus channel.</p>
</div></blockquote>
<p><strong>ias</strong> : bool</p>
<blockquote>
<div><p>Internal Active Shielding data (maybe on Triux only).</p>
</div></blockquote>
<p><strong>syst</strong> : bool</p>
<blockquote>
<div><p>System status channel information (on Triux systems only).</p>
</div></blockquote>
<p><strong>seeg</strong> : bool</p>
<blockquote>
<div><p>Stereotactic EEG channels.</p>
</div></blockquote>
<p><strong>bio</strong> : bool</p>
<blockquote>
<div><p>Bio channels.</p>
</div></blockquote>
<p><strong>ecog</strong> : bool</p>
<blockquote>
<div><p>Electrocorticography channels.</p>
</div></blockquote>
<p><strong>include</strong> : list of string</p>
<blockquote>
<div><p>List of additional channels to include. If empty do not include
any.</p>
</div></blockquote>
<p><strong>exclude</strong> : list of string | str</p>
<blockquote>
<div><p>List of channels to exclude. If &#8216;bads&#8217; (default), exclude channels
in <tt class="docutils literal"><span class="pre">info['bads']</span></tt>.</p>
</div></blockquote>
<p><strong>selection</strong> : list of string</p>
<blockquote>
<div><p>Restrict sensor channels (MEG, EEG) to this list of channel names.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>This parameter has been deprecated and will be removed in 0.13.
Use inst.copy() instead.
Whether to return a new instance or modify in place.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.plot">
<tt class="descname">plot</tt><big>(</big><em>picks=None</em>, <em>exclude='bads'</em>, <em>unit=True</em>, <em>show=True</em>, <em>ylim=None</em>, <em>xlim='tight'</em>, <em>proj=False</em>, <em>hline=None</em>, <em>units=None</em>, <em>scalings=None</em>, <em>titles=None</em>, <em>axes=None</em>, <em>gfp=False</em>, <em>window_title=None</em>, <em>spatial_colors=False</em><big>)</big><a class="headerlink" href="#mne.Evoked.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot evoked data using butterfly plots</p>
<p>Left click to a line shows the channel name. Selecting an area by
clicking and holding left mouse button plots a topographic map of the
painted area.</p>
<p>Note: If bad channels are not excluded they are shown in red.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>The indices of channels to plot. If None show all.</p>
</div></blockquote>
<p><strong>exclude</strong> : list of str | &#8216;bads&#8217;</p>
<blockquote>
<div><p>Channels names to exclude from being shown. If &#8216;bads&#8217;, the
bad channels are excluded.</p>
</div></blockquote>
<p><strong>unit</strong> : bool</p>
<blockquote>
<div><p>Scale plot with channel (SI) unit.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Call pyplot.show() at the end or not.</p>
</div></blockquote>
<p><strong>ylim</strong> : dict | None</p>
<blockquote>
<div><p>ylim for plots (after scaling has been applied). The value
determines the upper and lower subplot limits. e.g.
ylim = dict(eeg=[-20, 20]). Valid keys are eeg, mag, grad. If None,
the ylim parameter for each channel is determined by the maximum
absolute peak.</p>
</div></blockquote>
<p><strong>xlim</strong> : &#8216;tight&#8217; | tuple | None</p>
<blockquote>
<div><p>xlim for plots.</p>
</div></blockquote>
<p><strong>proj</strong> : bool | &#8216;interactive&#8217;</p>
<blockquote>
<div><p>If true SSP projections are applied before display. If
&#8216;interactive&#8217;, a check box for reversible selection of SSP
projection vectors will be shown.</p>
</div></blockquote>
<p><strong>hline</strong> : list of floats | None</p>
<blockquote>
<div><p>The values at which show an horizontal line.</p>
</div></blockquote>
<p><strong>units</strong> : dict | None</p>
<blockquote>
<div><p>The units of the channel types used for axes lables. If None,
defaults to <cite>dict(eeg=&#8217;uV&#8217;, grad=&#8217;fT/cm&#8217;, mag=&#8217;fT&#8217;)</cite>.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | None</p>
<blockquote>
<div><p>The scalings of the channel types to be applied for plotting.
If None, defaults to <cite>dict(eeg=1e6, grad=1e13, mag=1e15)</cite>.</p>
</div></blockquote>
<p><strong>titles</strong> : dict | None</p>
<blockquote>
<div><p>The titles associated with the channels. If None, defaults to
<cite>dict(eeg=&#8217;EEG&#8217;, grad=&#8217;Gradiometers&#8217;, mag=&#8217;Magnetometers&#8217;)</cite>.</p>
</div></blockquote>
<p><strong>axes</strong> : instance of Axes | list | None</p>
<blockquote>
<div><p>The axes to plot to. If list, the list must be a list of Axes of
the same length as the number of channel types. If instance of
Axes, there must be only one channel type plotted.</p>
</div></blockquote>
<p><strong>gfp</strong> : bool | &#8216;only&#8217;</p>
<blockquote>
<div><p>Plot GFP in green if True or &#8220;only&#8221;. If &#8220;only&#8221;, then the individual
channel traces will not be shown.</p>
</div></blockquote>
<p><strong>window_title</strong> : str | None</p>
<blockquote>
<div><p>The title to put at the top of the figure window.</p>
</div></blockquote>
<p><strong>spatial_colors</strong> : bool</p>
<blockquote>
<div><p>If True, the lines are color coded by mapping physical sensor
coordinates into color values. Spatially similar channels will have
similar colors. Bad channels will be dotted. If False, the good
channels are plotted black and bad channels red. Defaults to False.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib.figure.Figure</p>
<blockquote class="last">
<div><p>Figure containing the butterfly plots.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.plot_field">
<tt class="descname">plot_field</tt><big>(</big><em>surf_maps</em>, <em>time=None</em>, <em>time_label='t = %0.0f ms'</em>, <em>n_jobs=1</em><big>)</big><a class="headerlink" href="#mne.Evoked.plot_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot MEG/EEG fields on head surface and helmet in 3D</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>surf_maps</strong> : list</p>
<blockquote>
<div><p>The surface mapping information obtained with make_field_map.</p>
</div></blockquote>
<p><strong>time</strong> : float | None</p>
<blockquote>
<div><p>The time point at which the field map shall be displayed. If None,
the average peak latency (across sensor types) is used.</p>
</div></blockquote>
<p><strong>time_label</strong> : str</p>
<blockquote>
<div><p>How to print info about the time instant visualized.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int</p>
<blockquote>
<div><p>Number of jobs to run in parallel.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of mlab.Figure</p>
<blockquote class="last">
<div><p>The mayavi figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.plot_image">
<tt class="descname">plot_image</tt><big>(</big><em>picks=None</em>, <em>exclude='bads'</em>, <em>unit=True</em>, <em>show=True</em>, <em>clim=None</em>, <em>xlim='tight'</em>, <em>proj=False</em>, <em>units=None</em>, <em>scalings=None</em>, <em>titles=None</em>, <em>axes=None</em>, <em>cmap='RdBu_r'</em><big>)</big><a class="headerlink" href="#mne.Evoked.plot_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot evoked data as images</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>The indices of channels to plot. If None show all.</p>
</div></blockquote>
<p><strong>exclude</strong> : list of str | &#8216;bads&#8217;</p>
<blockquote>
<div><p>Channels names to exclude from being shown. If &#8216;bads&#8217;, the
bad channels are excluded.</p>
</div></blockquote>
<p><strong>unit</strong> : bool</p>
<blockquote>
<div><p>Scale plot with channel (SI) unit.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Call pyplot.show() at the end or not.</p>
</div></blockquote>
<p><strong>clim</strong> : dict</p>
<blockquote>
<div><p>clim for images. e.g. clim = dict(eeg=[-200e-6, 200e6])
Valid keys are eeg, mag, grad</p>
</div></blockquote>
<p><strong>xlim</strong> : &#8216;tight&#8217; | tuple | None</p>
<blockquote>
<div><p>xlim for plots.</p>
</div></blockquote>
<p><strong>proj</strong> : bool | &#8216;interactive&#8217;</p>
<blockquote>
<div><p>If true SSP projections are applied before display. If
&#8216;interactive&#8217;, a check box for reversible selection of SSP
projection vectors will be shown.</p>
</div></blockquote>
<p><strong>units</strong> : dict | None</p>
<blockquote>
<div><p>The units of the channel types used for axes lables. If None,
defaults to <cite>dict(eeg=&#8217;uV&#8217;, grad=&#8217;fT/cm&#8217;, mag=&#8217;fT&#8217;)</cite>.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | None</p>
<blockquote>
<div><p>The scalings of the channel types to be applied for plotting.
If None, defaults to <cite>dict(eeg=1e6, grad=1e13, mag=1e15)</cite>.</p>
</div></blockquote>
<p><strong>titles</strong> : dict | None</p>
<blockquote>
<div><p>The titles associated with the channels. If None, defaults to
<cite>dict(eeg=&#8217;EEG&#8217;, grad=&#8217;Gradiometers&#8217;, mag=&#8217;Magnetometers&#8217;)</cite>.</p>
</div></blockquote>
<p><strong>axes</strong> : instance of Axes | list | None</p>
<blockquote>
<div><p>The axes to plot to. If list, the list must be a list of Axes of
the same length as the number of channel types. If instance of
Axes, there must be only one channel type plotted.</p>
</div></blockquote>
<p><strong>cmap</strong> : matplotlib colormap</p>
<blockquote>
<div><p>Colormap.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib.figure.Figure</p>
<blockquote class="last">
<div><p>Figure containing the images.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.plot_joint">
<tt class="descname">plot_joint</tt><big>(</big><em>times='peaks'</em>, <em>title=''</em>, <em>picks=None</em>, <em>exclude='bads'</em>, <em>show=True</em>, <em>ts_args=None</em>, <em>topomap_args=None</em><big>)</big><a class="headerlink" href="#mne.Evoked.plot_joint" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot evoked data as butterfly plots and add topomaps for selected
time points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>times</strong> : float | array of floats | &#8220;auto&#8221; | &#8220;peaks&#8221;</p>
<blockquote>
<div><p>The time point(s) to plot. If &#8220;auto&#8221;, 5 evenly spaced topographies
between the first and last time instant will be shown. If &#8220;peaks&#8221;,
finds time points automatically by checking for 3 local
maxima in Global Field Power. Defaults to &#8220;peaks&#8221;.</p>
</div></blockquote>
<p><strong>title</strong> : str</p>
<blockquote>
<div><p>The title. If <tt class="docutils literal"><span class="pre">None</span></tt>, suppress printing channel type. Defaults to
an empty string.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>The indices of channels to plot. If <tt class="docutils literal"><span class="pre">None</span></tt>, show all. Defaults
to None.</p>
</div></blockquote>
<p><strong>exclude</strong> : list of str | &#8216;bads&#8217;</p>
<blockquote>
<div><p>Channels names to exclude from being shown. If &#8216;bads&#8217;, the
bad channels are excluded. Defaults to &#8216;bads&#8217;.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figure if True. Defaults to True.</p>
</div></blockquote>
<p><strong>ts_args</strong> : None | dict</p>
<blockquote>
<div><p>A dict of <cite>kwargs</cite> that are forwarded to <cite>evoked.plot</cite> to
style the butterfly plot. <cite>axes</cite> and <cite>show</cite> are ignored.
If <cite>spatial_colors</cite> is not in this dict, <cite>spatial_colors=True</cite>
will be passed. Beyond that, if <cite>None</cite>, no customizable arguments
will be passed.</p>
</div></blockquote>
<p><strong>topomap_args</strong> : None | dict</p>
<blockquote>
<div><p>A dict of <cite>kwargs</cite> that are forwarded to <cite>evoked.plot_topomap</cite>
to style the topomaps. <cite>axes</cite> and <cite>show</cite> are ignored. If <cite>times</cite>
is not in this dict, automatic peak detection is used. Beyond
that, if <cite>None</cite>, no customizable arguments will be passed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib.figure.Figure | list</p>
<blockquote class="last">
<div><p>The figure object containing the plot. If <cite>evoked</cite> has multiple
channel types, a list of figures, one for each channel type, is
returned.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.12.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.plot_projs_topomap">
<tt class="descname">plot_projs_topomap</tt><big>(</big><em>ch_type=None</em>, <em>layout=None</em>, <em>axes=None</em><big>)</big><a class="headerlink" href="#mne.Evoked.plot_projs_topomap" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot SSP vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_type</strong> : &#8216;mag&#8217; | &#8216;grad&#8217; | &#8216;planar1&#8217; | &#8216;planar2&#8217; | &#8216;eeg&#8217; | None | List</p>
<blockquote>
<div><p>The channel type to plot. For &#8216;grad&#8217;, the gradiometers are collec-
ted in pairs and the RMS for each pair is plotted. If None
(default), it will return all channel types present. If a list of
ch_types is provided, it will return multiple figures.</p>
</div></blockquote>
<p><strong>layout</strong> : None | Layout | List of Layouts</p>
<blockquote>
<div><p>Layout instance specifying sensor positions (does not need to
be specified for Neuromag data). If possible, the correct
layout file is inferred from the data; if no appropriate layout
file was found, the layout is automatically generated from the
sensor locations. Or a list of Layout if projections
are from different sensor types.</p>
</div></blockquote>
<p><strong>axes</strong> : instance of Axes | list | None</p>
<blockquote>
<div><p>The axes to plot to. If list, the list must be a list of Axes of
the same length as the number of projectors. If instance of Axes,
there must be only one projector. Defaults to None.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote class="last">
<div><p>Figure distributing one image per channel across sensor topography.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.plot_sensors">
<tt class="descname">plot_sensors</tt><big>(</big><em>kind='topomap'</em>, <em>ch_type=None</em>, <em>title=None</em>, <em>show_names=False</em>, <em>show=True</em><big>)</big><a class="headerlink" href="#mne.Evoked.plot_sensors" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot sensors positions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kind</strong> : str</p>
<blockquote>
<div><p>Whether to plot the sensors as 3d or as topomap. Available options
&#8216;topomap&#8217;, &#8216;3d&#8217;. Defaults to &#8216;topomap&#8217;.</p>
</div></blockquote>
<p><strong>ch_type</strong> : &#8216;mag&#8217; | &#8216;grad&#8217; | &#8216;eeg&#8217; | &#8216;seeg&#8217; | &#8216;ecog&#8217; | None</p>
<blockquote>
<div><p>The channel type to plot. If None, then channels are chosen in the
order given above.</p>
</div></blockquote>
<p><strong>title</strong> : str | None</p>
<blockquote>
<div><p>Title for the figure. If None (default), equals to
<tt class="docutils literal"><span class="pre">'Sensor</span> <span class="pre">positions</span> <span class="pre">(%s)'</span> <span class="pre">%</span> <span class="pre">ch_type</span></tt>.</p>
</div></blockquote>
<p><strong>show_names</strong> : bool</p>
<blockquote>
<div><p>Whether to display all channel names. Defaults to False.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figure if True. Defaults to True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote class="last">
<div><p>Figure containing the sensor topography.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.viz.plot_layout.html#mne.viz.plot_layout" title="mne.viz.plot_layout"><tt class="xref py py-obj docutils literal"><span class="pre">mne.viz.plot_layout</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<p>This function plots the sensor locations from the info structure using
matplotlib. For drawing the sensors using mayavi see
<a class="reference internal" href="mne.viz.plot_trans.html#mne.viz.plot_trans" title="mne.viz.plot_trans"><tt class="xref py py-func docutils literal"><span class="pre">mne.viz.plot_trans()</span></tt></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.12.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.plot_topo">
<tt class="descname">plot_topo</tt><big>(</big><em>layout=None, layout_scale=0.945, color=None, border='none', ylim=None, scalings=None, title=None, proj=False, vline=[0.0], fig_facecolor='k', fig_background=None, axis_facecolor='k', font_color='w', merge_grads=False, show=True</em><big>)</big><a class="headerlink" href="#mne.Evoked.plot_topo" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot 2D topography of evoked responses.</p>
<p>Clicking on the plot of an individual sensor opens a new figure showing
the evoked response for the selected sensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>layout</strong> : instance of Layout | None</p>
<blockquote>
<div><p>Layout instance specifying sensor positions (does not need to
be specified for Neuromag data). If possible, the correct layout is
inferred from the data.</p>
</div></blockquote>
<p><strong>layout_scale: float</strong> :</p>
<blockquote>
<div><p>Scaling factor for adjusting the relative size of the layout
on the canvas</p>
</div></blockquote>
<p><strong>color</strong> : list of color objects | color object | None</p>
<blockquote>
<div><p>Everything matplotlib accepts to specify colors. If not list-like,
the color specified will be repeated. If None, colors are
automatically drawn.</p>
</div></blockquote>
<p><strong>border</strong> : str</p>
<blockquote>
<div><p>matplotlib borders style to be used for each sensor plot.</p>
</div></blockquote>
<p><strong>ylim</strong> : dict | None</p>
<blockquote>
<div><p>ylim for plots. The value determines the upper and lower subplot
limits. e.g. ylim = dict(eeg=[-20, 20]). Valid keys are eeg,
mag, grad, misc. If None, the ylim parameter for each channel is
determined by the maximum absolute peak.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | None</p>
<blockquote>
<div><p>The scalings of the channel types to be applied for plotting. If
None, defaults to <cite>dict(eeg=1e6, grad=1e13, mag=1e15)</cite>.</p>
</div></blockquote>
<p><strong>title</strong> : str</p>
<blockquote>
<div><p>Title of the figure.</p>
</div></blockquote>
<p><strong>proj</strong> : bool | &#8216;interactive&#8217;</p>
<blockquote>
<div><p>If true SSP projections are applied before display. If
&#8216;interactive&#8217;, a check box for reversible selection of SSP
projection vectors will be shown.</p>
</div></blockquote>
<p><strong>vline</strong> : list of floats | None</p>
<blockquote>
<div><p>The values at which to show a vertical line.</p>
</div></blockquote>
<p><strong>fig_facecolor</strong> : str | obj</p>
<blockquote>
<div><p>The figure face color. Defaults to black.</p>
</div></blockquote>
<p><strong>fig_background</strong> : None | numpy ndarray</p>
<blockquote>
<div><p>A background image for the figure. This must work with a call to
plt.imshow. Defaults to None.</p>
</div></blockquote>
<p><strong>axis_facecolor</strong> : str | obj</p>
<blockquote>
<div><p>The face color to be used for each sensor plot. Defaults to black.</p>
</div></blockquote>
<p><strong>font_color</strong> : str | obj</p>
<blockquote>
<div><p>The color of text in the colorbar and title. Defaults to white.</p>
</div></blockquote>
<p><strong>merge_grads</strong> : bool</p>
<blockquote>
<div><p>Whether to use RMS value of gradiometer pairs. Only works for
Neuromag data. Defaults to False.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figure if True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Instance of matplotlib.figure.Figure</p>
<blockquote class="last">
<div><p>Images of evoked responses at sensor locations</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.10.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.plot_topomap">
<tt class="descname">plot_topomap</tt><big>(</big><em>times='auto'</em>, <em>ch_type=None</em>, <em>layout=None</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>cmap=None</em>, <em>sensors=True</em>, <em>colorbar=True</em>, <em>scale=None</em>, <em>scale_time=1000.0</em>, <em>unit=None</em>, <em>res=64</em>, <em>size=1</em>, <em>cbar_fmt='%3.1f'</em>, <em>time_format='%01d ms'</em>, <em>proj=False</em>, <em>show=True</em>, <em>show_names=False</em>, <em>title=None</em>, <em>mask=None</em>, <em>mask_params=None</em>, <em>outlines='head'</em>, <em>contours=6</em>, <em>image_interp='bilinear'</em>, <em>average=None</em>, <em>head_pos=None</em>, <em>axes=None</em><big>)</big><a class="headerlink" href="#mne.Evoked.plot_topomap" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot topographic maps of specific time points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>times</strong> : float | array of floats | &#8220;auto&#8221; | &#8220;peaks&#8221;.</p>
<blockquote>
<div><p>The time point(s) to plot. If &#8220;auto&#8221;, the number of <tt class="docutils literal"><span class="pre">axes</span></tt>
determines the amount of time point(s). If <tt class="docutils literal"><span class="pre">axes</span></tt> is also None,
10 topographies will be shown with a regular time spacing between
the first and last time instant. If &#8220;peaks&#8221;, finds time points
automatically by checking for local maxima in Global Field Power.</p>
</div></blockquote>
<p><strong>ch_type</strong> : &#8216;mag&#8217; | &#8216;grad&#8217; | &#8216;planar1&#8217; | &#8216;planar2&#8217; | &#8216;eeg&#8217; | None</p>
<blockquote>
<div><p>The channel type to plot. For &#8216;grad&#8217;, the gradiometers are collec-
ted in pairs and the RMS for each pair is plotted.
If None, then first available channel type from order given
above is used. Defaults to None.</p>
</div></blockquote>
<p><strong>layout</strong> : None | Layout</p>
<blockquote>
<div><p>Layout instance specifying sensor positions (does not need to
be specified for Neuromag data). If possible, the correct
layout file is inferred from the data; if no appropriate layout
file was found, the layout is automatically generated from the
sensor locations.</p>
</div></blockquote>
<p><strong>vmin</strong> : float | callable</p>
<blockquote>
<div><p>The value specfying the lower bound of the color range.
If None, and vmax is None, -vmax is used. Else np.min(data).
If callable, the output equals vmin(data).</p>
</div></blockquote>
<p><strong>vmax</strong> : float | callable</p>
<blockquote>
<div><p>The value specfying the upper bound of the color range.
If None, the maximum absolute value is used. If vmin is None,
but vmax is not, defaults to np.max(data).
If callable, the output equals vmax(data).</p>
</div></blockquote>
<p><strong>cmap</strong> : matplotlib colormap | None</p>
<blockquote>
<div><p>Colormap to use. If None, &#8216;Reds&#8217; is used for all positive data,
otherwise defaults to &#8216;RdBu_r&#8217;.</p>
</div></blockquote>
<p><strong>sensors</strong> : bool | str</p>
<blockquote>
<div><p>Add markers for sensor locations to the plot. Accepts matplotlib
plot format string (e.g., &#8216;r+&#8217; for red plusses). If True, a circle
will be used (via .add_artist). Defaults to True.</p>
</div></blockquote>
<p><strong>colorbar</strong> : bool</p>
<blockquote>
<div><p>Plot a colorbar.</p>
</div></blockquote>
<p><strong>scale</strong> : dict | float | None</p>
<blockquote>
<div><p>Scale the data for plotting. If None, defaults to 1e6 for eeg, 1e13
for grad and 1e15 for mag.</p>
</div></blockquote>
<p><strong>scale_time</strong> : float | None</p>
<blockquote>
<div><p>Scale the time labels. Defaults to 1e3 (ms).</p>
</div></blockquote>
<p><strong>unit</strong> : dict | str | None</p>
<blockquote>
<div><p>The unit of the channel type used for colorbar label. If
scale is None the unit is automatically determined.</p>
</div></blockquote>
<p><strong>res</strong> : int</p>
<blockquote>
<div><p>The resolution of the topomap image (n pixels along each side).</p>
</div></blockquote>
<p><strong>size</strong> : scalar</p>
<blockquote>
<div><p>Side length of the topomaps in inches (only applies when plotting
multiple topomaps at a time).</p>
</div></blockquote>
<p><strong>cbar_fmt</strong> : str</p>
<blockquote>
<div><p>String format for colorbar values.</p>
</div></blockquote>
<p><strong>time_format</strong> : str</p>
<blockquote>
<div><p>String format for topomap values. Defaults to <tt class="docutils literal"><span class="pre">&quot;%01d</span> <span class="pre">ms&quot;</span></tt>.</p>
</div></blockquote>
<p><strong>proj</strong> : bool | &#8216;interactive&#8217;</p>
<blockquote>
<div><p>If true SSP projections are applied before display. If
&#8216;interactive&#8217;, a check box for reversible selection of SSP
projection vectors will be shown.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Call pyplot.show() at the end.</p>
</div></blockquote>
<p><strong>show_names</strong> : bool | callable</p>
<blockquote>
<div><p>If True, show channel names on top of the map. If a callable is
passed, channel names will be formatted using the callable; e.g.,
to delete the prefix &#8216;MEG &#8216; from all channel names, pass the
function
lambda x: x.replace(&#8216;MEG &#8216;, &#8216;&#8217;). If <cite>mask</cite> is not None, only
significant sensors will be shown.</p>
</div></blockquote>
<p><strong>title</strong> : str | None</p>
<blockquote>
<div><p>Title. If None (default), no title is displayed.</p>
</div></blockquote>
<p><strong>mask</strong> : ndarray of bool, shape (n_channels, n_times) | None</p>
<blockquote>
<div><p>The channels to be marked as significant at a given time point.
Indices set to <cite>True</cite> will be considered. Defaults to None.</p>
</div></blockquote>
<p><strong>mask_params</strong> : dict | None</p>
<blockquote>
<div><p>Additional plotting parameters for plotting significant sensors.
Default (None) equals:
<tt class="docutils literal"><span class="pre">dict(marker='o',</span> <span class="pre">markerfacecolor='w',</span> <span class="pre">markeredgecolor='k',</span>
<span class="pre">linewidth=0,</span> <span class="pre">markersize=4)</span></tt>.</p>
</div></blockquote>
<p><strong>outlines</strong> : &#8216;head&#8217; | &#8216;skirt&#8217; | dict | None</p>
<blockquote>
<div><p>The outlines to be drawn. If &#8216;head&#8217;, the default head scheme will
be drawn. If &#8216;skirt&#8217; the head scheme will be drawn, but sensors are
allowed to be plotted outside of the head circle. If dict, each key
refers to a tuple of x and y positions, the values in &#8216;mask_pos&#8217;
will serve as image mask, and the &#8216;autoshrink&#8217; (bool) field will
trigger automated shrinking of the positions due to points outside
the outline. Alternatively, a matplotlib patch object can be passed
for advanced masking options, either directly or as a function that
returns patches (required for multi-axis plots). If None, nothing
will be drawn. Defaults to &#8216;head&#8217;.</p>
</div></blockquote>
<p><strong>contours</strong> : int | False | None</p>
<blockquote>
<div><p>The number of contour lines to draw. If 0, no contours will be
drawn.</p>
</div></blockquote>
<p><strong>image_interp</strong> : str</p>
<blockquote>
<div><p>The image interpolation to be used. All matplotlib options are
accepted.</p>
</div></blockquote>
<p><strong>average</strong> : float | None</p>
<blockquote>
<div><p>The time window around a given time to be used for averaging
(seconds). For example, 0.01 would translate into window that
starts 5 ms before and ends 5 ms after a given time point.
Defaults to None, which means no averaging.</p>
</div></blockquote>
<p><strong>head_pos</strong> : dict | None</p>
<blockquote>
<div><p>If None (default), the sensors are positioned such that they span
the head circle. If dict, can have entries &#8216;center&#8217; (tuple) and
&#8216;scale&#8217; (tuple) for what the center and scale of the head should be
relative to the electrode locations.</p>
</div></blockquote>
<p><strong>axes</strong> : instance of Axes | list | None</p>
<blockquote>
<div><p>The axes to plot to. If list, the list must be a list of Axes of
the same length as <tt class="docutils literal"><span class="pre">times</span></tt> (unless <tt class="docutils literal"><span class="pre">times</span></tt> is None). If
instance of Axes, <tt class="docutils literal"><span class="pre">times</span></tt> must be a float or a list of one float.
Defaults to None.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib.figure.Figure</p>
<blockquote class="last">
<div><p>Images of evoked responses at sensor locations</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.plot_white">
<tt class="descname">plot_white</tt><big>(</big><em>noise_cov</em>, <em>show=True</em><big>)</big><a class="headerlink" href="#mne.Evoked.plot_white" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot whitened evoked response</p>
<p>Plots the whitened evoked response and the whitened GFP as described in
<a class="reference internal" href="#r5" id="id1">[R5]</a>. If one single covariance object is passed, the GFP panel (bottom)
will depict different sensor types. If multiple covariance objects are
passed as a list, the left column will display the whitened evoked
responses for each channel based on the whitener from the noise
covariance that has the highest log-likelihood. The left column will
depict the whitened GFPs based on each estimator separately for each
sensor type. Instead of numbers of channels the GFP display shows the
estimated rank. The rank estimation will be printed by the logger for
each noise covariance estimator that is passed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>noise_cov</strong> : list | instance of Covariance | str</p>
<blockquote>
<div><p>The noise covariance as computed by <tt class="docutils literal"><span class="pre">mne.cov.compute_covariance</span></tt>.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Whether to show the figure or not. Defaults to True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib.figure.Figure</p>
<blockquote class="last">
<div><p>The figure object containing the plot.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R5]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> Engemann D. and Gramfort A. (2015) Automated model selection in
covariance estimation and spatial whitening of MEG and EEG
signals, vol. 108, 328-342, NeuroImage.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.rename_channels">
<tt class="descname">rename_channels</tt><big>(</big><em>mapping</em><big>)</big><a class="headerlink" href="#mne.Evoked.rename_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mapping</strong> : dict | callable</p>
<blockquote class="last">
<div><p>a dictionary mapping the old channel to a new channel name
e.g. {&#8216;EEG061&#8217; : &#8216;EEG161&#8217;}. Can also be a callable function
that takes and returns a string (new in version 0.10.0).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.resample">
<tt class="descname">resample</tt><big>(</big><em>sfreq</em>, <em>npad=None</em>, <em>window='boxcar'</em><big>)</big><a class="headerlink" href="#mne.Evoked.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample data</p>
<p>This function operates in-place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sfreq</strong> : float</p>
<blockquote>
<div><p>New sample rate to use</p>
</div></blockquote>
<p><strong>npad</strong> : int | str</p>
<blockquote>
<div><p>Amount to pad the start and end of the data.
Can also be &#8220;auto&#8221; to use a padding that will result in
a power-of-two size (can be much faster).</p>
</div></blockquote>
<p><strong>window</strong> : string or tuple</p>
<blockquote class="last">
<div><p>Window to use in resampling. See scipy.signal.resample.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.save">
<tt class="descname">save</tt><big>(</big><em>fname</em><big>)</big><a class="headerlink" href="#mne.Evoked.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save dataset to file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fname</strong> : string</p>
<blockquote class="last">
<div><p>Name of the file where to save the data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>To write multiple conditions into a single file, use
<a class="reference internal" href="mne.write_evokeds.html#mne.write_evokeds" title="mne.write_evokeds"><tt class="xref py py-func docutils literal"><span class="pre">mne.write_evokeds()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.savgol_filter">
<tt class="descname">savgol_filter</tt><big>(</big><em>h_freq</em>, <em>copy=False</em><big>)</big><a class="headerlink" href="#mne.Evoked.savgol_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter the data using Savitzky-Golay polynomial method</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>h_freq</strong> : float</p>
<blockquote>
<div><p>Approximate high cut-off frequency in Hz. Note that this
is not an exact cutoff, since Savitzky-Golay filtering <a class="reference internal" href="#r6" id="id3">[R6]</a> is
done using polynomial fits instead of FIR/IIR filtering.
This parameter is thus used to determine the length of the
window over which a 5th-order polynomial smoothing is used.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>If True, a copy of the object, filtered, is returned.
If False (default), it operates on the object in place.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Epochs or Evoked</p>
<blockquote class="last">
<div><p>The object with the filtering applied.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.io.Raw.html#mne.io.Raw.filter" title="mne.io.Raw.filter"><tt class="xref py py-obj docutils literal"><span class="pre">mne.io.Raw.filter</span></tt></a></p>
</div>
<p class="rubric">Notes</p>
<p>For Savitzky-Golay low-pass approximation, see:</p>
<blockquote>
<div><a class="reference external" href="https://gist.github.com/Eric89GXL/bbac101d50176611136b">https://gist.github.com/Eric89GXL/bbac101d50176611136b</a></div></blockquote>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R6]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> Savitzky, A., Golay, M.J.E. (1964). &#8220;Smoothing and
Differentiation of Data by Simplified Least Squares
Procedures&#8221;. Analytical Chemistry 36 (8): 1627-39.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mne</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">path</span> <span class="k">as</span> <span class="n">op</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked_fname</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mne</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">data_path</span><span class="p">(),</span> <span class="s1">&#39;MEG&#39;</span><span class="p">,</span> <span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;sample_audvis-ave.fif&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_evokeds</span><span class="p">(</span><span class="n">evoked_fname</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="mf">10.</span><span class="p">)</span>  <span class="c1"># low-pass at around 10 Hz </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.set_channel_types">
<tt class="descname">set_channel_types</tt><big>(</big><em>mapping</em><big>)</big><a class="headerlink" href="#mne.Evoked.set_channel_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the sensor type of channels.</p>
<dl class="docutils">
<dt>Note: The following sensor types are accepted:</dt>
<dd>ecg, eeg, emg, eog, exci, ias, misc, resp, seeg, stim, syst, ecog</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mapping</strong> : dict</p>
<blockquote class="last">
<div><p>a dictionary mapping a channel to a sensor type (str)
{&#8216;EEG061&#8217;: &#8216;eog&#8217;}.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.set_montage">
<tt class="descname">set_montage</tt><big>(</big><em>montage</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.Evoked.set_montage" title="Permalink to this definition">¶</a></dt>
<dd><p>Set EEG sensor configuration</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>montage</strong> : instance of Montage or DigMontage</p>
<blockquote>
<div><p>The montage to use.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Operates in place.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.shift_time">
<tt class="descname">shift_time</tt><big>(</big><em>tshift</em>, <em>relative=True</em><big>)</big><a class="headerlink" href="#mne.Evoked.shift_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift time scale in evoked data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tshift</strong> : float</p>
<blockquote>
<div><p>The amount of time shift to be applied if relative is True
else the first time point. When relative is True, positive value
of tshift moves the data forward while negative tshift moves it
backward.</p>
</div></blockquote>
<p><strong>relative</strong> : bool</p>
<blockquote class="last">
<div><p>If true, move the time backwards or forwards by specified amount.
Else, set the starting time point to the value of tshift.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Maximum accuracy of time shift is 1 / evoked.info[&#8216;sfreq&#8217;]</p>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.time_as_index">
<tt class="descname">time_as_index</tt><big>(</big><em>times</em>, <em>use_rounding=False</em><big>)</big><a class="headerlink" href="#mne.Evoked.time_as_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert time to indices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>times</strong> : list-like | float | int</p>
<blockquote>
<div><p>List of numbers or a number representing points in time.</p>
</div></blockquote>
<p><strong>use_rounding</strong> : boolean</p>
<blockquote>
<div><p>If True, use rounding (instead of truncation) when converting
times to indices. This can help avoid non-unique indices.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>index</strong> : ndarray</p>
<blockquote class="last">
<div><p>Indices corresponding to the times supplied.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.to_data_frame">
<tt class="descname">to_data_frame</tt><big>(</big><em>picks=None</em>, <em>index=None</em>, <em>scale_time=1000.0</em>, <em>scalings=None</em>, <em>copy=True</em>, <em>start=None</em>, <em>stop=None</em><big>)</big><a class="headerlink" href="#mne.Evoked.to_data_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Export data in tabular structure as a pandas DataFrame.</p>
<p>Columns and indices will depend on the object being converted.
Generally this will include as much relevant information as
possible for the data type being converted. This makes it easy
to convert data for use in packages that utilize dataframes,
such as statsmodels or seaborn.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>If None only MEG and EEG channels are kept
otherwise the channels indices in picks are kept.</p>
</div></blockquote>
<p><strong>index</strong> : tuple of str | None</p>
<blockquote>
<div><p>Column to be used as index for the data. Valid string options
are &#8216;epoch&#8217;, &#8216;time&#8217; and &#8216;condition&#8217;. If None, all three info
columns will be included in the table as categorial data.</p>
</div></blockquote>
<p><strong>scale_time</strong> : float</p>
<blockquote>
<div><p>Scaling to be applied to time units.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | None</p>
<blockquote>
<div><p>Scaling to be applied to the channels picked. If None, defaults to
<tt class="docutils literal"><span class="pre">scalings=dict(eeg=1e6,</span> <span class="pre">grad=1e13,</span> <span class="pre">mag=1e15,</span> <span class="pre">misc=1.0)</span></tt>.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>If true, data will be copied. Else data may be modified in place.</p>
</div></blockquote>
<p><strong>start</strong> : int | None</p>
<blockquote>
<div><p>If it is a Raw object, this defines a starting index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</div></blockquote>
<p><strong>stop</strong> : int | None</p>
<blockquote>
<div><p>If it is a Raw object, this defines a stop index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>df</strong> : instance of pandas.core.DataFrame</p>
<blockquote class="last">
<div><p>A dataframe suitable for usage with other
statistical/plotting/analysis packages. Column/Index values will
depend on the object type being converted, but should be
human-readable.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


    </div>
    
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2012-2016, MNE Developers. Last updated on 2016-05-11.<br/>
    </p>
  </div>
</footer>
  </body>
</html>