<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mne.preprocessing.ICA &mdash; MNE 0.12.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootswatch-3.3.4/flatly/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.12.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.4/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="MNE 0.12.0 documentation" href="../index.html" />
    <link rel="up" title="Python API Reference" href="../python_reference.html" />
    <link rel="next" title="mne.preprocessing.Xdawn" href="mne.preprocessing.Xdawn.html" />
    <link rel="prev" title="mne.Projection" href="mne.Projection.html" />

<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,400,700' rel='stylesheet' type='text/css'>


    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37225609-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>



    <script type="text/javascript">
    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);
    js.id=id;js.src="http://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
    </script>



    <script type="text/javascript">
    (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    </script>


  </head>
  <body>





  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><img src="../_static/mne_logo_small.png">
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.12.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../getting_started.html">Get started</a></li>
                <li><a href="../tutorials.html">Tutorials</a></li>
                <li><a href="../auto_examples/index.html">Gallery</a></li>
                <li><a href="../python_reference.html">API</a></li>
                <li><a href="../manual/index.html">Manual</a></li>
                <li><a href="../faq.html">FAQ</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contribute to MNE</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../python_reference.html">Python API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../manual/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whats_new.html">What&#8217;s new</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cite.html">How to cite MNE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">Related publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cited.html">Publications from MNE users</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">mne.preprocessing.ICA</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/mne_logo_small.png" alt="Logo"/>
            </a></p><ul>
<li><a class="reference internal" href="#">mne.preprocessing.ICA</a></li>
</ul>

  <li>
    <a href="mne.Projection.html" title="Previous Chapter: mne.Projection"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; mne.Projection</span>
    </a>
  </li>
  <li>
    <a href="mne.preprocessing.Xdawn.html" title="Next Chapter: mne.preprocessing.Xdawn"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">mne.preproces... &raquo;</span>
    </a>
  </li>
<form action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="col-md-12">
      
  <div class="section" id="mne-preprocessing-ica">
<h1>mne.preprocessing.ICA<a class="headerlink" href="#mne-preprocessing-ica" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="mne.preprocessing.ICA">
<em class="property">class </em><tt class="descclassname">mne.preprocessing.</tt><tt class="descname">ICA</tt><big>(</big><em>n_components=None</em>, <em>max_pca_components=None</em>, <em>n_pca_components=None</em>, <em>noise_cov=None</em>, <em>random_state=None</em>, <em>method='fastica'</em>, <em>fit_params=None</em>, <em>max_iter=200</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.preprocessing.ICA" title="Permalink to this definition">¶</a></dt>
<dd><p>M/EEG signal decomposition using Independent Component Analysis (ICA)</p>
<p>This object can be used to estimate ICA components and then
remove some from Raw or Epochs for data exploration or artifact
correction.</p>
<p>Caveat! If supplying a noise covariance keep track of the projections
available in the cov or in the raw object. For example, if you are
interested in EOG or ECG artifacts, EOG and ECG projections should be
temporally removed before fitting the ICA. You can say:</p>
<div class="highlight-python"><div class="highlight"><pre>&gt;&gt; projs, raw.info[&#39;projs&#39;] = raw.info[&#39;projs&#39;], []
&gt;&gt; ica.fit(raw)
&gt;&gt; raw.info[&#39;projs&#39;] = projs
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Methods implemented are FastICA (default), Infomax and
Extended-Infomax. Infomax can be quite sensitive to differences
in floating point arithmetic due to exponential non-linearity.
Extended-Infomax seems to be more stable in this respect
enhancing reproducibility and stability of results.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n_components</strong> : int | float | None</p>
<blockquote>
<div><p>The number of components used for ICA decomposition. If int, it must be
smaller then max_pca_components. If None, all PCA components will be
used. If float between 0 and 1 components will be selected by the
cumulative percentage of explained variance.</p>
</div></blockquote>
<p><strong>max_pca_components</strong> : int | None</p>
<blockquote>
<div><p>The number of components used for PCA decomposition. If None, no
dimension reduction will be applied and max_pca_components will equal
the number of channels supplied on decomposing data. Defaults to None.</p>
</div></blockquote>
<p><strong>n_pca_components</strong> : int | float</p>
<blockquote>
<div><p>The number of PCA components used after ICA recomposition. The ensuing
attribute allows to balance noise reduction against potential loss of
features due to dimensionality reduction. If greater than
<tt class="docutils literal"><span class="pre">self.n_components_</span></tt>, the next <tt class="docutils literal"><span class="pre">n_pca_components</span></tt> minus
<tt class="docutils literal"><span class="pre">n_components_</span></tt> PCA components will be added before restoring the
sensor space data. The attribute gets updated each time the according
parameter for in .pick_sources_raw or .pick_sources_epochs is changed.
If float, the number of components selected matches the number of
components with a cumulative explained variance below
<cite>n_pca_components</cite>.</p>
</div></blockquote>
<p><strong>noise_cov</strong> : None | instance of mne.cov.Covariance</p>
<blockquote>
<div><p>Noise covariance used for whitening. If None, channels are just
z-scored.</p>
</div></blockquote>
<p><strong>random_state</strong> : None | int | instance of np.random.RandomState</p>
<blockquote>
<div><p>np.random.RandomState to initialize the FastICA estimation.
As the estimation is non-deterministic it can be useful to
fix the seed to have reproducible results. Defaults to None.</p>
</div></blockquote>
<p><strong>method</strong> : {&#8216;fastica&#8217;, &#8216;infomax&#8217;, &#8216;extended-infomax&#8217;}</p>
<blockquote>
<div><p>The ICA method to use. Defaults to &#8216;fastica&#8217;.</p>
</div></blockquote>
<p><strong>fit_params</strong> : dict | None.</p>
<blockquote>
<div><p>Additional parameters passed to the ICA estimator chosen by <cite>method</cite>.</p>
</div></blockquote>
<p><strong>max_iter</strong> : int, optional</p>
<blockquote>
<div><p>Maximum number of iterations during fit.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><p class="first"><strong>current_fit</strong> : str</p>
<blockquote>
<div><p>Flag informing about which data type (raw or epochs) was used for
the fit.</p>
</div></blockquote>
<p><strong>ch_names</strong> : list-like</p>
<blockquote>
<div><p>Channel names resulting from initial picking.
The number of components used for ICA decomposition.</p>
</div></blockquote>
<p><strong>``n_components_``</strong> : int</p>
<blockquote>
<div><p>If fit, the actual number of components used for ICA decomposition.</p>
</div></blockquote>
<p><strong>n_pca_components</strong> : int</p>
<blockquote>
<div><p>See above.</p>
</div></blockquote>
<p><strong>max_pca_components</strong> : int</p>
<blockquote>
<div><p>The number of components used for PCA dimensionality reduction.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>See above.</p>
</div></blockquote>
<p><strong>``pca_components_`</strong> : ndarray</p>
<blockquote>
<div><p>If fit, the PCA components</p>
</div></blockquote>
<p><strong>``pca_mean_``</strong> : ndarray</p>
<blockquote>
<div><p>If fit, the mean vector used to center the data before doing the PCA.</p>
</div></blockquote>
<p><strong>``pca_explained_variance_``</strong> : ndarray</p>
<blockquote>
<div><p>If fit, the variance explained by each PCA component</p>
</div></blockquote>
<p><strong>``mixing_matrix_``</strong> : ndarray</p>
<blockquote>
<div><p>If fit, the mixing matrix to restore observed data, else None.</p>
</div></blockquote>
<p><strong>``unmixing_matrix_``</strong> : ndarray</p>
<blockquote>
<div><p>If fit, the matrix to unmix observed data, else None.</p>
</div></blockquote>
<p><strong>exclude</strong> : list</p>
<blockquote>
<div><p>List of sources indices to exclude, i.e. artifact components identified
throughout the ICA solution. Indices added to this list, will be
dispatched to the .pick_sources methods. Source indices passed to
the .pick_sources method via the &#8216;exclude&#8217; argument are added to the
.exclude attribute. When saving the ICA also the indices are restored.
Hence, artifact components once identified don&#8217;t have to be added
again. To dump this &#8216;artifact memory&#8217; say: ica.exclude = []</p>
</div></blockquote>
<p><strong>info</strong> : None | instance of Info</p>
<blockquote>
<div><p>The measurement info copied from the object fitted.</p>
</div></blockquote>
<p><strong>`n_samples_`</strong> : int</p>
<blockquote>
<div><p>the number of samples used on fit.</p>
</div></blockquote>
<p><strong>`labels_`</strong> : dict</p>
<blockquote class="last">
<div><p>A dictionary of independent component indices, grouped by types of
independent components. This attribute is set by some of the artifact
detection functions.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mne.preprocessing.ICA.apply" title="mne.preprocessing.ICA.apply"><tt class="xref py py-obj docutils literal"><span class="pre">apply</span></tt></a>(inst[,&nbsp;include,&nbsp;exclude,&nbsp;...])</td>
<td>Remove selected components from the signal.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.preprocessing.ICA.copy" title="mne.preprocessing.ICA.copy"><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt></a>()</td>
<td>Copy the ICA object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.preprocessing.ICA.detect_artifacts" title="mne.preprocessing.ICA.detect_artifacts"><tt class="xref py py-obj docutils literal"><span class="pre">detect_artifacts</span></tt></a>(raw[,&nbsp;start_find,&nbsp;...])</td>
<td>Run ICA artifacts detection workflow.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.preprocessing.ICA.find_bads_ecg" title="mne.preprocessing.ICA.find_bads_ecg"><tt class="xref py py-obj docutils literal"><span class="pre">find_bads_ecg</span></tt></a>(inst[,&nbsp;ch_name,&nbsp;threshold,&nbsp;...])</td>
<td>Detect ECG related components using correlation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.preprocessing.ICA.find_bads_eog" title="mne.preprocessing.ICA.find_bads_eog"><tt class="xref py py-obj docutils literal"><span class="pre">find_bads_eog</span></tt></a>(inst[,&nbsp;ch_name,&nbsp;threshold,&nbsp;...])</td>
<td>Detect EOG related components using correlation</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.preprocessing.ICA.fit" title="mne.preprocessing.ICA.fit"><tt class="xref py py-obj docutils literal"><span class="pre">fit</span></tt></a>(inst[,&nbsp;picks,&nbsp;start,&nbsp;stop,&nbsp;decim,&nbsp;...])</td>
<td>Run the ICA decomposition on raw data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.preprocessing.ICA.get_sources" title="mne.preprocessing.ICA.get_sources"><tt class="xref py py-obj docutils literal"><span class="pre">get_sources</span></tt></a>(inst[,&nbsp;add_channels,&nbsp;start,&nbsp;stop])</td>
<td>Estimate sources given the unmixing matrix</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.preprocessing.ICA.plot_components" title="mne.preprocessing.ICA.plot_components"><tt class="xref py py-obj docutils literal"><span class="pre">plot_components</span></tt></a>([picks,&nbsp;ch_type,&nbsp;res,&nbsp;...])</td>
<td>Project unmixing matrix on interpolated sensor topography.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.preprocessing.ICA.plot_overlay" title="mne.preprocessing.ICA.plot_overlay"><tt class="xref py py-obj docutils literal"><span class="pre">plot_overlay</span></tt></a>(inst[,&nbsp;exclude,&nbsp;picks,&nbsp;start,&nbsp;...])</td>
<td>Overlay of raw and cleaned signals given the unmixing matrix.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.preprocessing.ICA.plot_scores" title="mne.preprocessing.ICA.plot_scores"><tt class="xref py py-obj docutils literal"><span class="pre">plot_scores</span></tt></a>(scores[,&nbsp;exclude,&nbsp;labels,&nbsp;...])</td>
<td>Plot scores related to detected components.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.preprocessing.ICA.plot_sources" title="mne.preprocessing.ICA.plot_sources"><tt class="xref py py-obj docutils literal"><span class="pre">plot_sources</span></tt></a>(inst[,&nbsp;picks,&nbsp;exclude,&nbsp;start,&nbsp;...])</td>
<td>Plot estimated latent sources given the unmixing matrix.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.preprocessing.ICA.save" title="mne.preprocessing.ICA.save"><tt class="xref py py-obj docutils literal"><span class="pre">save</span></tt></a>(fname)</td>
<td>Store ICA solution into a fiff file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.preprocessing.ICA.score_sources" title="mne.preprocessing.ICA.score_sources"><tt class="xref py py-obj docutils literal"><span class="pre">score_sources</span></tt></a>(inst[,&nbsp;target,&nbsp;score_func,&nbsp;...])</td>
<td>Assign score to components based on statistic or metric</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="mne.preprocessing.ICA.__init__">
<tt class="descname">__init__</tt><big>(</big><em>n_components=None</em>, <em>max_pca_components=None</em>, <em>n_pca_components=None</em>, <em>noise_cov=None</em>, <em>random_state=None</em>, <em>method='fastica'</em>, <em>fit_params=None</em>, <em>max_iter=200</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.preprocessing.ICA.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mne.preprocessing.ICA.apply">
<tt class="descname">apply</tt><big>(</big><em>inst</em>, <em>include=None</em>, <em>exclude=None</em>, <em>n_pca_components=None</em>, <em>start=None</em>, <em>stop=None</em>, <em>copy=None</em><big>)</big><a class="headerlink" href="#mne.preprocessing.ICA.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove selected components from the signal.</p>
<p>Given the unmixing matrix, transform data,
zero out components, and inverse transform the data.
This procedure will reconstruct M/EEG signals from which
the dynamics described by the excluded components is subtracted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs or Evoked</p>
<blockquote>
<div><p>The data to be processed.</p>
</div></blockquote>
<p><strong>include</strong> : array_like of int.</p>
<blockquote>
<div><p>The indices referring to columns in the ummixing matrix. The
components to be kept.</p>
</div></blockquote>
<p><strong>exclude</strong> : array_like of int.</p>
<blockquote>
<div><p>The indices referring to columns in the ummixing matrix. The
components to be zeroed out.</p>
</div></blockquote>
<p><strong>n_pca_components</strong> : int | float | None</p>
<blockquote>
<div><p>The number of PCA components to be kept, either absolute (int)
or percentage of the explained variance (float). If None (default),
all PCA components will be used.</p>
</div></blockquote>
<p><strong>start</strong> : int | float | None</p>
<blockquote>
<div><p>First sample to include. If float, data will be interpreted as
time in seconds. If None, data will be used from the first sample.</p>
</div></blockquote>
<p><strong>stop</strong> : int | float | None</p>
<blockquote>
<div><p>Last sample to not include. If float, data will be interpreted as
time in seconds. If None, data will be used to the last sample.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote class="last">
<div><p>This parameter has been deprecated and will be removed in 0.13.
Use inst.copy() instead.
Whether to return a new instance or modify in place.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.preprocessing.ICA.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#mne.preprocessing.ICA.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the ICA object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ica</strong> : instance of ICA</p>
<blockquote class="last">
<div><p>The copied object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.preprocessing.ICA.detect_artifacts">
<tt class="descname">detect_artifacts</tt><big>(</big><em>raw</em>, <em>start_find=None</em>, <em>stop_find=None</em>, <em>ecg_ch=None</em>, <em>ecg_score_func='pearsonr'</em>, <em>ecg_criterion=0.1</em>, <em>eog_ch=None</em>, <em>eog_score_func='pearsonr'</em>, <em>eog_criterion=0.1</em>, <em>skew_criterion=-1</em>, <em>kurt_criterion=-1</em>, <em>var_criterion=0</em>, <em>add_nodes=None</em><big>)</big><a class="headerlink" href="#mne.preprocessing.ICA.detect_artifacts" title="Permalink to this definition">¶</a></dt>
<dd><p>Run ICA artifacts detection workflow.</p>
<p>Note. This is still experimental and will most likely change. Over
the next releases. For maximum control use the workflow exposed in
the examples.</p>
<p>Hints and caveats:
- It is highly recommended to bandpass filter ECG and EOG
data and pass them instead of the channel names as ecg_ch and eog_ch
arguments.
- please check your results. Detection by kurtosis and variance
may be powerful but misclassification of brain signals as
noise cannot be precluded.
- Consider using shorter times for start_find and stop_find than
for start and stop. It can save you much time.</p>
<p>Example invocation (taking advantage of the defaults):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ica</span><span class="o">.</span><span class="n">detect_artifacts</span><span class="p">(</span><span class="n">ecg_channel</span><span class="o">=</span><span class="s1">&#39;MEG 1531&#39;</span><span class="p">,</span> <span class="n">eog_channel</span><span class="o">=</span><span class="s1">&#39;EOG 061&#39;</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>raw</strong> : instance of Raw</p>
<blockquote>
<div><p>Raw object to draw sources from.</p>
</div></blockquote>
<p><strong>start_find</strong> : int | float | None</p>
<blockquote>
<div><p>First sample to include for artifact search. If float, data will be
interpreted as time in seconds. If None, data will be used from the
first sample.</p>
</div></blockquote>
<p><strong>stop_find</strong> : int | float | None</p>
<blockquote>
<div><p>Last sample to not include for artifact search. If float, data will
be interpreted as time in seconds. If None, data will be used to
the last sample.</p>
</div></blockquote>
<p><strong>ecg_ch</strong> : str | ndarray | None</p>
<blockquote>
<div><p>The <cite>target</cite> argument passed to ica.find_sources_raw. Either the
name of the ECG channel or the ECG time series. If None, this step
will be skipped.</p>
</div></blockquote>
<p><strong>ecg_score_func</strong> : str | callable</p>
<blockquote>
<div><p>The <cite>score_func</cite> argument passed to ica.find_sources_raw. Either
the name of function supported by ICA or a custom function.</p>
</div></blockquote>
<p><strong>ecg_criterion</strong> : float | int | list-like | slice</p>
<blockquote>
<div><p>The indices of the sorted skewness scores. If float, sources with
scores smaller than the criterion will be dropped. Else, the scores
sorted in descending order will be indexed accordingly.
E.g. range(2) would return the two sources with the highest score.
If None, this step will be skipped.</p>
</div></blockquote>
<p><strong>eog_ch</strong> : list | str | ndarray | None</p>
<blockquote>
<div><p>The <cite>target</cite> argument or the list of target arguments subsequently
passed to ica.find_sources_raw. Either the name of the vertical EOG
channel or the corresponding EOG time series. If None, this step
will be skipped.</p>
</div></blockquote>
<p><strong>eog_score_func</strong> : str | callable</p>
<blockquote>
<div><p>The <cite>score_func</cite> argument passed to ica.find_sources_raw. Either
the name of function supported by ICA or a custom function.</p>
</div></blockquote>
<p><strong>eog_criterion</strong> : float | int | list-like | slice</p>
<blockquote>
<div><p>The indices of the sorted skewness scores. If float, sources with
scores smaller than the criterion will be dropped. Else, the scores
sorted in descending order will be indexed accordingly.
E.g. range(2) would return the two sources with the highest score.
If None, this step will be skipped.</p>
</div></blockquote>
<p><strong>skew_criterion</strong> : float | int | list-like | slice</p>
<blockquote>
<div><p>The indices of the sorted skewness scores. If float, sources with
scores smaller than the criterion will be dropped. Else, the scores
sorted in descending order will be indexed accordingly.
E.g. range(2) would return the two sources with the highest score.
If None, this step will be skipped.</p>
</div></blockquote>
<p><strong>kurt_criterion</strong> : float | int | list-like | slice</p>
<blockquote>
<div><p>The indices of the sorted skewness scores. If float, sources with
scores smaller than the criterion will be dropped. Else, the scores
sorted in descending order will be indexed accordingly.
E.g. range(2) would return the two sources with the highest score.
If None, this step will be skipped.</p>
</div></blockquote>
<p><strong>var_criterion</strong> : float | int | list-like | slice</p>
<blockquote>
<div><p>The indices of the sorted skewness scores. If float, sources with
scores smaller than the criterion will be dropped. Else, the scores
sorted in descending order will be indexed accordingly.
E.g. range(2) would return the two sources with the highest score.
If None, this step will be skipped.</p>
</div></blockquote>
<p><strong>add_nodes</strong> : list of ica_nodes</p>
<blockquote>
<div><p>Additional list if tuples carrying the following parameters:
(name : str, target : str | array, score_func : callable,
criterion : float | int | list-like | slice). This parameter is a
generalization of the artifact specific parameters above and has
the same structure. Example:
add_nodes=(&#8216;ECG phase lock&#8217;, ECG 01&#8217;, my_phase_lock_function, 0.5)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : instance of ICA</p>
<blockquote class="last">
<div><p>The ica object with the detected artifact indices marked for
exclusion</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.preprocessing.ICA.find_bads_ecg">
<tt class="descname">find_bads_ecg</tt><big>(</big><em>inst</em>, <em>ch_name=None</em>, <em>threshold=None</em>, <em>start=None</em>, <em>stop=None</em>, <em>l_freq=8</em>, <em>h_freq=16</em>, <em>method='ctps'</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.preprocessing.ICA.find_bads_ecg" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect ECG related components using correlation</p>
<p>Note. If no ECG channel is available, routine attempts to create
an artificial ECG based on cross-channel averaging.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs or Evoked</p>
<blockquote>
<div><p>Object to compute sources from.</p>
</div></blockquote>
<p><strong>ch_name</strong> : str</p>
<blockquote>
<div><p>The name of the channel to use for ECG peak detection.
The argument is mandatory if the dataset contains no ECG
channels.</p>
</div></blockquote>
<p><strong>threshold</strong> : float</p>
<blockquote>
<div><p>The value above which a feature is classified as outlier. If
method is &#8216;ctps&#8217;, defaults to 0.25, else defaults to 3.0.</p>
</div></blockquote>
<p><strong>start</strong> : int | float | None</p>
<blockquote>
<div><p>First sample to include. If float, data will be interpreted as
time in seconds. If None, data will be used from the first sample.</p>
</div></blockquote>
<p><strong>stop</strong> : int | float | None</p>
<blockquote>
<div><p>Last sample to not include. If float, data will be interpreted as
time in seconds. If None, data will be used to the last sample.</p>
</div></blockquote>
<p><strong>l_freq</strong> : float</p>
<blockquote>
<div><p>Low pass frequency.</p>
</div></blockquote>
<p><strong>h_freq</strong> : float</p>
<blockquote>
<div><p>High pass frequency.</p>
</div></blockquote>
<p><strong>method</strong> : {&#8216;ctps&#8217;, &#8216;correlation&#8217;}</p>
<blockquote>
<div><p>The method used for detection. If &#8216;ctps&#8217;, cross-trial phase
statistics [1] are used to detect ECG related components.
Thresholding is then based on the significance value of a Kuiper
statistic.
If &#8216;correlation&#8217;, detection is based on Pearson correlation
between the filtered data and the filtered ECG channel.
Thresholding is based on iterative z-scoring. The above
threshold components will be masked and the z-score will
be recomputed until no supra-threshold component remains.
Defaults to &#8216;ctps&#8217;.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ecg_idx</strong> : list of int</p>
<blockquote>
<div><p>The indices of ECG related components.</p>
</div></blockquote>
<p><strong>scores</strong> : np.ndarray of float, shape (<tt class="docutils literal"><span class="pre">n_components_</span></tt>)</p>
<blockquote class="last">
<div><p>The correlation scores.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.preprocessing.ICA.find_bads_eog" title="mne.preprocessing.ICA.find_bads_eog"><tt class="xref py py-obj docutils literal"><span class="pre">find_bads_eog</span></tt></a></p>
</div>
<p class="rubric">References</p>
<dl class="docutils">
<dt>[1] Dammers, J., Schiek, M., Boers, F., Silex, C., Zvyagintsev,</dt>
<dd>M., Pietrzyk, U., Mathiak, K., 2008. Integration of amplitude
and phase statistics for complete artifact removal in independent
components of neuromagnetic recordings. Biomedical
Engineering, IEEE Transactions on 55 (10), 2353-2362.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mne.preprocessing.ICA.find_bads_eog">
<tt class="descname">find_bads_eog</tt><big>(</big><em>inst</em>, <em>ch_name=None</em>, <em>threshold=3.0</em>, <em>start=None</em>, <em>stop=None</em>, <em>l_freq=1</em>, <em>h_freq=10</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.preprocessing.ICA.find_bads_eog" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect EOG related components using correlation</p>
<p>Detection is based on Pearson correlation between the
filtered data and the filtered EOG channel.
Thresholding is based on adaptive z-scoring. The above threshold
components will be masked and the z-score will be recomputed
until no supra-threshold component remains.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs or Evoked</p>
<blockquote>
<div><p>Object to compute sources from.</p>
</div></blockquote>
<p><strong>ch_name</strong> : str</p>
<blockquote>
<div><p>The name of the channel to use for EOG peak detection.
The argument is mandatory if the dataset contains no ECG
channels.</p>
</div></blockquote>
<p><strong>threshold</strong> : int | float</p>
<blockquote>
<div><p>The value above which a feature is classified as outlier.</p>
</div></blockquote>
<p><strong>start</strong> : int | float | None</p>
<blockquote>
<div><p>First sample to include. If float, data will be interpreted as
time in seconds. If None, data will be used from the first sample.</p>
</div></blockquote>
<p><strong>stop</strong> : int | float | None</p>
<blockquote>
<div><p>Last sample to not include. If float, data will be interpreted as
time in seconds. If None, data will be used to the last sample.</p>
</div></blockquote>
<p><strong>l_freq</strong> : float</p>
<blockquote>
<div><p>Low pass frequency.</p>
</div></blockquote>
<p><strong>h_freq</strong> : float</p>
<blockquote>
<div><p>High pass frequency.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>eog_idx</strong> : list of int</p>
<blockquote>
<div><p>The indices of EOG related components, sorted by score.</p>
</div></blockquote>
<p><strong>scores</strong> : np.ndarray of float, shape (<tt class="docutils literal"><span class="pre">n_components_</span></tt>) | list of array</p>
<blockquote class="last">
<div><p>The correlation scores.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.preprocessing.ICA.find_bads_ecg" title="mne.preprocessing.ICA.find_bads_ecg"><tt class="xref py py-obj docutils literal"><span class="pre">find_bads_ecg</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.preprocessing.ICA.fit">
<tt class="descname">fit</tt><big>(</big><em>inst</em>, <em>picks=None</em>, <em>start=None</em>, <em>stop=None</em>, <em>decim=None</em>, <em>reject=None</em>, <em>flat=None</em>, <em>tstep=2.0</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.preprocessing.ICA.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the ICA decomposition on raw data</p>
<p>Caveat! If supplying a noise covariance keep track of the projections
available in the cov, the raw or the epochs object. For example,
if you are interested in EOG or ECG artifacts, EOG and ECG projections
should be temporally removed before fitting the ICA.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs or Evoked</p>
<blockquote>
<div><p>Raw measurements to be decomposed.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int</p>
<blockquote>
<div><p>Channels to be included. This selection remains throughout the
initialized ICA solution. If None only good data channels are used.</p>
</div></blockquote>
<p><strong>start</strong> : int | float | None</p>
<blockquote>
<div><p>First sample to include. If float, data will be interpreted as
time in seconds. If None, data will be used from the first sample.</p>
</div></blockquote>
<p><strong>stop</strong> : int | float | None</p>
<blockquote>
<div><p>Last sample to not include. If float, data will be interpreted as
time in seconds. If None, data will be used to the last sample.</p>
</div></blockquote>
<p><strong>decim</strong> : int | None</p>
<blockquote>
<div><p>Increment for selecting each nth time slice. If None, all samples
within <tt class="docutils literal"><span class="pre">start</span></tt> and <tt class="docutils literal"><span class="pre">stop</span></tt> are used.</p>
</div></blockquote>
<p><strong>reject</strong> : dict | None</p>
<blockquote>
<div><p>Rejection parameters based on peak-to-peak amplitude.
Valid keys are &#8216;grad&#8217;, &#8216;mag&#8217;, &#8216;eeg&#8217;, &#8216;seeg&#8217;, &#8216;ecog&#8217;, &#8216;eog&#8217;, &#8216;ecg&#8217;.
If reject is None then no rejection is done. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">reject</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">grad</span><span class="o">=</span><span class="mf">4000e-13</span><span class="p">,</span> <span class="c1"># T / m (gradiometers)</span>
              <span class="n">mag</span><span class="o">=</span><span class="mf">4e-12</span><span class="p">,</span> <span class="c1"># T (magnetometers)</span>
              <span class="n">eeg</span><span class="o">=</span><span class="mf">40e-6</span><span class="p">,</span> <span class="c1"># V (EEG channels)</span>
              <span class="n">eog</span><span class="o">=</span><span class="mf">250e-6</span> <span class="c1"># V (EOG channels)</span>
              <span class="p">)</span>
</pre></div>
</div>
<p>It only applies if <cite>inst</cite> is of type Raw.</p>
</div></blockquote>
<p><strong>flat</strong> : dict | None</p>
<blockquote>
<div><p>Rejection parameters based on flatness of signal.
Valid keys are &#8216;grad&#8217;, &#8216;mag&#8217;, &#8216;eeg&#8217;, &#8216;seeg&#8217;, &#8216;ecog&#8217;, &#8216;eog&#8217;, &#8216;ecg&#8217;.
Values are floats that set the minimum acceptable peak-to-peak
amplitude. If flat is None then no rejection is done.
It only applies if <cite>inst</cite> is of type Raw.</p>
</div></blockquote>
<p><strong>tstep</strong> : float</p>
<blockquote>
<div><p>Length of data chunks for artifact rejection in seconds.
It only applies if <cite>inst</cite> is of type Raw.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : instance of ICA</p>
<blockquote class="last">
<div><p>Returns the modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.preprocessing.ICA.get_sources">
<tt class="descname">get_sources</tt><big>(</big><em>inst</em>, <em>add_channels=None</em>, <em>start=None</em>, <em>stop=None</em><big>)</big><a class="headerlink" href="#mne.preprocessing.ICA.get_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate sources given the unmixing matrix</p>
<p>This method will return the sources in the container format passed.
Typical usecases:</p>
<ol class="arabic simple">
<li>pass Raw object to use <cite>raw.plot</cite> for ICA sources</li>
<li>pass Epochs object to compute trial-based statistics in ICA space</li>
<li>pass Evoked object to investigate time-locking in ICA space</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs or Evoked</p>
<blockquote>
<div><p>Object to compute sources from and to represent sources in.</p>
</div></blockquote>
<p><strong>add_channels</strong> : None | list of str</p>
<blockquote>
<div><p>Additional channels  to be added. Useful to e.g. compare sources
with some reference. Defaults to None</p>
</div></blockquote>
<p><strong>start</strong> : int | float | None</p>
<blockquote>
<div><p>First sample to include. If float, data will be interpreted as
time in seconds. If None, the entire data will be used.</p>
</div></blockquote>
<p><strong>stop</strong> : int | float | None</p>
<blockquote>
<div><p>Last sample to not include. If float, data will be interpreted as
time in seconds. If None, the entire data will be used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sources</strong> : instance of Raw, Epochs or Evoked</p>
<blockquote class="last">
<div><p>The ICA sources time series.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.preprocessing.ICA.plot_components">
<tt class="descname">plot_components</tt><big>(</big><em>picks=None</em>, <em>ch_type=None</em>, <em>res=64</em>, <em>layout=None</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>cmap='RdBu_r'</em>, <em>sensors=True</em>, <em>colorbar=False</em>, <em>title=None</em>, <em>show=True</em>, <em>outlines='head'</em>, <em>contours=6</em>, <em>image_interp='bilinear'</em>, <em>head_pos=None</em><big>)</big><a class="headerlink" href="#mne.preprocessing.ICA.plot_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Project unmixing matrix on interpolated sensor topography.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : int | array-like | None</p>
<blockquote>
<div><p>The indices of the sources to be plotted.
If None all are plotted in batches of 20.</p>
</div></blockquote>
<p><strong>ch_type</strong> : &#8216;mag&#8217; | &#8216;grad&#8217; | &#8216;planar1&#8217; | &#8216;planar2&#8217; | &#8216;eeg&#8217; | None</p>
<blockquote>
<div><p>The channel type to plot. For &#8216;grad&#8217;, the gradiometers are
collected in pairs and the RMS for each pair is plotted.
If None, then first available channel type from order given
above is used. Defaults to None.</p>
</div></blockquote>
<p><strong>res</strong> : int</p>
<blockquote>
<div><p>The resolution of the topomap image (n pixels along each side).</p>
</div></blockquote>
<p><strong>layout</strong> : None | Layout</p>
<blockquote>
<div><p>Layout instance specifying sensor positions (does not need to
be specified for Neuromag data). If possible, the correct layout is
inferred from the data.</p>
</div></blockquote>
<p><strong>vmin</strong> : float | callable</p>
<blockquote>
<div><p>The value specfying the lower bound of the color range.
If None, and vmax is None, -vmax is used. Else np.min(data).
If callable, the output equals vmin(data).</p>
</div></blockquote>
<p><strong>vmax</strong> : float | callable</p>
<blockquote>
<div><p>The value specfying the upper bound of the color range.
If None, the maximum absolute value is used. If vmin is None,
but vmax is not, defaults to np.min(data).
If callable, the output equals vmax(data).</p>
</div></blockquote>
<p><strong>cmap</strong> : matplotlib colormap</p>
<blockquote>
<div><p>Colormap.</p>
</div></blockquote>
<p><strong>sensors</strong> : bool | str</p>
<blockquote>
<div><p>Add markers for sensor locations to the plot. Accepts matplotlib
plot format string (e.g., &#8216;r+&#8217; for red plusses). If True, a circle
will be used (via .add_artist). Defaults to True.</p>
</div></blockquote>
<p><strong>colorbar</strong> : bool</p>
<blockquote>
<div><p>Plot a colorbar.</p>
</div></blockquote>
<p><strong>title</strong> : str | None</p>
<blockquote>
<div><p>Title to use.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Call pyplot.show() at the end.</p>
</div></blockquote>
<p><strong>outlines</strong> : &#8216;head&#8217; | &#8216;skirt&#8217; | dict | None</p>
<blockquote>
<div><p>The outlines to be drawn. If &#8216;head&#8217;, the default head scheme will
be drawn. If &#8216;skirt&#8217; the head scheme will be drawn, but sensors are
allowed to be plotted outside of the head circle. If dict, each key
refers to a tuple of x and y positions, the values in &#8216;mask_pos&#8217;
will serve as image mask, and the &#8216;autoshrink&#8217; (bool) field will
trigger automated shrinking of the positions due to points outside
the outline. Alternatively, a matplotlib patch object can be passed
for advanced masking options, either directly or as a function that
returns patches (required for multi-axis plots). If None, nothing
will be drawn. Defaults to &#8216;head&#8217;.</p>
</div></blockquote>
<p><strong>contours</strong> : int | False | None</p>
<blockquote>
<div><p>The number of contour lines to draw. If 0, no contours will
be drawn.</p>
</div></blockquote>
<p><strong>image_interp</strong> : str</p>
<blockquote>
<div><p>The image interpolation to be used. All matplotlib options are
accepted.</p>
</div></blockquote>
<p><strong>head_pos</strong> : dict | None</p>
<blockquote>
<div><p>If None (default), the sensors are positioned such that they span
the head circle. If dict, can have entries &#8216;center&#8217; (tuple) and
&#8216;scale&#8217; (tuple) for what the center and scale of the head should be
relative to the electrode locations.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib.pyplot.Figure</p>
<blockquote class="last">
<div><p>The figure object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.preprocessing.ICA.plot_overlay">
<tt class="descname">plot_overlay</tt><big>(</big><em>inst</em>, <em>exclude=None</em>, <em>picks=None</em>, <em>start=None</em>, <em>stop=None</em>, <em>title=None</em>, <em>show=True</em><big>)</big><a class="headerlink" href="#mne.preprocessing.ICA.plot_overlay" title="Permalink to this definition">¶</a></dt>
<dd><p>Overlay of raw and cleaned signals given the unmixing matrix.</p>
<p>This method helps visualizing signal quality and artifact rejection.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of mne.io.Raw or mne.Evoked</p>
<blockquote>
<div><p>The signals to be compared given the ICA solution. If Raw input,
The raw data are displayed before and after cleaning. In a second
panel the cross channel average will be displayed. Since dipolar
sources will be canceled out this display is sensitive to
artifacts. If evoked input, butterfly plots for clean and raw
signals will be superimposed.</p>
</div></blockquote>
<p><strong>exclude</strong> : array_like of int</p>
<blockquote>
<div><p>The components marked for exclusion. If None (default), ICA.exclude
will be used.</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None (default)</p>
<blockquote>
<div><p>Indices of channels to include (if None, all channels
are used that were included on fitting).</p>
</div></blockquote>
<p><strong>start</strong> : int</p>
<blockquote>
<div><p>X-axis start index. If None from the beginning.</p>
</div></blockquote>
<p><strong>stop</strong> : int</p>
<blockquote>
<div><p>X-axis stop index. If None to the end.</p>
</div></blockquote>
<p><strong>title</strong> : str</p>
<blockquote>
<div><p>The figure title.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>If True, all open plots will be shown.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of pyplot.Figure</p>
<blockquote class="last">
<div><p>The figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.preprocessing.ICA.plot_scores">
<tt class="descname">plot_scores</tt><big>(</big><em>scores</em>, <em>exclude=None</em>, <em>labels=None</em>, <em>axhline=None</em>, <em>title='ICA component scores'</em>, <em>figsize=(12</em>, <em>6)</em>, <em>show=True</em><big>)</big><a class="headerlink" href="#mne.preprocessing.ICA.plot_scores" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot scores related to detected components.</p>
<p>Use this function to assess how well your score describes outlier
sources and how well you were detecting them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>scores</strong> : array_like of float, shape (n ica components,) | list of array</p>
<blockquote>
<div><p>Scores based on arbitrary metric to characterize ICA components.</p>
</div></blockquote>
<p><strong>exclude</strong> : array_like of int</p>
<blockquote>
<div><p>The components marked for exclusion. If None (default), ICA.exclude
will be used.</p>
</div></blockquote>
<p><strong>labels</strong> : str | list | &#8216;ecg&#8217; | &#8216;eog&#8217; | None</p>
<blockquote>
<div><p>The labels to consider for the axes tests. Defaults to None.
If list, should match the outer shape of <cite>scores</cite>.
If &#8216;ecg&#8217; or &#8216;eog&#8217;, the <tt class="docutils literal"><span class="pre">labels_</span></tt> attributes will be looked up.
Note that &#8216;/&#8217; is used internally for sublabels specifying ECG and
EOG channels.</p>
</div></blockquote>
<p><strong>axhline</strong> : float</p>
<blockquote>
<div><p>Draw horizontal line to e.g. visualize rejection threshold.</p>
</div></blockquote>
<p><strong>title</strong> : str</p>
<blockquote>
<div><p>The figure title.</p>
</div></blockquote>
<p><strong>figsize</strong> : tuple of int</p>
<blockquote>
<div><p>The figure size. Defaults to (12, 6).</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>If True, all open plots will be shown.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib.pyplot.Figure</p>
<blockquote class="last">
<div><p>The figure object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.preprocessing.ICA.plot_sources">
<tt class="descname">plot_sources</tt><big>(</big><em>inst</em>, <em>picks=None</em>, <em>exclude=None</em>, <em>start=None</em>, <em>stop=None</em>, <em>title=None</em>, <em>show=True</em>, <em>block=False</em><big>)</big><a class="headerlink" href="#mne.preprocessing.ICA.plot_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot estimated latent sources given the unmixing matrix.</p>
<p>Typical usecases:</p>
<ol class="arabic simple">
<li>plot evolution of latent sources over time based on (Raw input)</li>
<li>plot latent source around event related time windows (Epochs input)</li>
<li>plot time-locking in ICA space (Evoked input)</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of mne.io.Raw, mne.Epochs, mne.Evoked</p>
<blockquote>
<div><p>The object to plot the sources from.</p>
</div></blockquote>
<p><strong>picks</strong> : ndarray | None.</p>
<blockquote>
<div><p>The components to be displayed. If None, plot will show the
sources in the order as fitted.</p>
</div></blockquote>
<p><strong>exclude</strong> : array_like of int</p>
<blockquote>
<div><p>The components marked for exclusion. If None (default), ICA.exclude
will be used.</p>
</div></blockquote>
<p><strong>start</strong> : int</p>
<blockquote>
<div><p>X-axis start index. If None from the beginning.</p>
</div></blockquote>
<p><strong>stop</strong> : int</p>
<blockquote>
<div><p>X-axis stop index. If None to the end.</p>
</div></blockquote>
<p><strong>title</strong> : str | None</p>
<blockquote>
<div><p>The figure title. If None a default is provided.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>If True, all open plots will be shown.</p>
</div></blockquote>
<p><strong>block</strong> : bool</p>
<blockquote>
<div><p>Whether to halt program execution until the figure is closed.
Useful for interactive selection of components in raw and epoch
plotter. For evoked, this parameter has no effect. Defaults to
False.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of pyplot.Figure</p>
<blockquote class="last">
<div><p>The figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For raw and epoch instances, it is possible to select components for
exclusion by clicking on the line. The selected components are added to
<tt class="docutils literal"><span class="pre">ica.exclude</span></tt> on close. The independent components can be viewed as
topographies by clicking on the component name on the left of of the
main axes. The topography view tries to infer the correct electrode
layout from the data. This should work at least for Neuromag data.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.10.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.preprocessing.ICA.save">
<tt class="descname">save</tt><big>(</big><em>fname</em><big>)</big><a class="headerlink" href="#mne.preprocessing.ICA.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Store ICA solution into a fiff file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fname</strong> : str</p>
<blockquote class="last">
<div><p>The absolute path of the file name to save the ICA solution into.
The file name should end with -ica.fif or -ica.fif.gz.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.preprocessing.ICA.score_sources">
<tt class="descname">score_sources</tt><big>(</big><em>inst</em>, <em>target=None</em>, <em>score_func='pearsonr'</em>, <em>start=None</em>, <em>stop=None</em>, <em>l_freq=None</em>, <em>h_freq=None</em>, <em>verbose=None</em><big>)</big><a class="headerlink" href="#mne.preprocessing.ICA.score_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign score to components based on statistic or metric</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs or Evoked</p>
<blockquote>
<div><p>The object to reconstruct the sources from.</p>
</div></blockquote>
<p><strong>target</strong> : array-like | ch_name | None</p>
<blockquote>
<div><p>Signal to which the sources shall be compared. It has to be of
the same shape as the sources. If some string is supplied, a
routine will try to find a matching channel. If None, a score
function expecting only one input-array argument must be used,
for instance, scipy.stats.skew (default).</p>
</div></blockquote>
<p><strong>score_func</strong> : callable | str label</p>
<blockquote>
<div><p>Callable taking as arguments either two input arrays
(e.g. Pearson correlation) or one input
array (e. g. skewness) and returns a float. For convenience the
most common score_funcs are available via string labels:
Currently, all distance metrics from scipy.spatial and All
functions from scipy.stats taking compatible input arguments are
supported. These function have been modified to support iteration
over the rows of a 2D array.</p>
</div></blockquote>
<p><strong>start</strong> : int | float | None</p>
<blockquote>
<div><p>First sample to include. If float, data will be interpreted as
time in seconds. If None, data will be used from the first sample.</p>
</div></blockquote>
<p><strong>stop</strong> : int | float | None</p>
<blockquote>
<div><p>Last sample to not include. If float, data will be interpreted as
time in seconds. If None, data will be used to the last sample.</p>
</div></blockquote>
<p><strong>l_freq</strong> : float</p>
<blockquote>
<div><p>Low pass frequency.</p>
</div></blockquote>
<p><strong>h_freq</strong> : float</p>
<blockquote>
<div><p>High pass frequency.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>scores</strong> : ndarray</p>
<blockquote class="last">
<div><p>scores for each source as returned from score_func</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


    </div>
    
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2012-2016, MNE Developers. Last updated on 2016-05-11.<br/>
    </p>
  </div>
</footer>
  </body>
</html>