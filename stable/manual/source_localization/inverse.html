<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>The minimum-norm current estimates &mdash; MNE 0.12.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootswatch-3.3.4/flatly/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.12.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.3.4/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="top" title="MNE 0.12.0 documentation" href="../../index.html" />
    <link rel="up" title="User Manual" href="../index.html" />
    <link rel="next" title="Morphing and averaging" href="morph.html" />
    <link rel="prev" title="The forward solution" href="forward.html" />

<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,400,700' rel='stylesheet' type='text/css'>


    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37225609-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>



    <script type="text/javascript">
    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);
    js.id=id;js.src="http://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
    </script>



    <script type="text/javascript">
    (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    </script>


  </head>
  <body>





  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html"><img src="../../_static/mne_logo_small.png">
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.12.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../getting_started.html">Get started</a></li>
                <li><a href="../../tutorials.html">Tutorials</a></li>
                <li><a href="../../auto_examples/index.html">Gallery</a></li>
                <li><a href="../../python_reference.html">API</a></li>
                <li><a href="../index.html">Manual</a></li>
                <li><a href="../../faq.html">FAQ</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../auto_examples/index.html">Examples Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contribute to MNE</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../python_reference.html">Python API Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../whats_new.html">What&#8217;s new</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../cite.html">How to cite MNE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references.html">Related publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cited.html">Publications from MNE users</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">The minimum-norm current estimates</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#minimum-norm-estimates">Minimum-norm estimates</a><ul>
<li><a class="reference internal" href="#the-linear-inverse-operator">The linear inverse operator</a></li>
<li><a class="reference internal" href="#regularization">Regularization</a></li>
<li><a class="reference internal" href="#whitening-and-scaling">Whitening and scaling</a></li>
<li><a class="reference internal" href="#regularization-of-the-noise-covariance-matrix">Regularization of the noise-covariance matrix</a></li>
<li><a class="reference internal" href="#computation-of-the-solution">Computation of the solution</a></li>
<li><a class="reference internal" href="#noise-normalization">Noise normalization</a></li>
<li><a class="reference internal" href="#predicted-data">Predicted data</a></li>
<li><a class="reference internal" href="#cortical-patch-statistics">Cortical patch statistics</a></li>
<li><a class="reference internal" href="#the-orientation-constraints">The orientation constraints</a></li>
<li><a class="reference internal" href="#depth-weighting">Depth weighting</a></li>
<li><a class="reference internal" href="#fmri-guided-estimates">fMRI-guided estimates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#effective-number-of-averages">Effective number of averages</a></li>
<li><a class="reference internal" href="#inverse-operator-decomposition">Inverse-operator decomposition</a></li>
<li><a class="reference internal" href="#producing-movies-and-snapshots">Producing movies and snapshots</a></li>
<li><a class="reference internal" href="#computing-inverse-from-raw-and-evoked-data">Computing inverse from raw and evoked data</a><ul>
<li><a class="reference internal" href="#implementation-details">Implementation details</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/mne_logo_small.png" alt="Logo"/>
            </a></p><ul>
<li><a class="reference internal" href="#">The minimum-norm current estimates</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#minimum-norm-estimates">Minimum-norm estimates</a><ul>
<li><a class="reference internal" href="#the-linear-inverse-operator">The linear inverse operator</a></li>
<li><a class="reference internal" href="#regularization">Regularization</a></li>
<li><a class="reference internal" href="#whitening-and-scaling">Whitening and scaling</a></li>
<li><a class="reference internal" href="#regularization-of-the-noise-covariance-matrix">Regularization of the noise-covariance matrix</a></li>
<li><a class="reference internal" href="#computation-of-the-solution">Computation of the solution</a></li>
<li><a class="reference internal" href="#noise-normalization">Noise normalization</a></li>
<li><a class="reference internal" href="#predicted-data">Predicted data</a></li>
<li><a class="reference internal" href="#cortical-patch-statistics">Cortical patch statistics</a></li>
<li><a class="reference internal" href="#the-orientation-constraints">The orientation constraints</a></li>
<li><a class="reference internal" href="#depth-weighting">Depth weighting</a></li>
<li><a class="reference internal" href="#fmri-guided-estimates">fMRI-guided estimates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#effective-number-of-averages">Effective number of averages</a></li>
<li><a class="reference internal" href="#inverse-operator-decomposition">Inverse-operator decomposition</a></li>
<li><a class="reference internal" href="#producing-movies-and-snapshots">Producing movies and snapshots</a></li>
<li><a class="reference internal" href="#computing-inverse-from-raw-and-evoked-data">Computing inverse from raw and evoked data</a><ul>
<li><a class="reference internal" href="#implementation-details">Implementation details</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <li>
    <a href="forward.html" title="Previous Chapter: The forward solution"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; The forward s...</span>
    </a>
  </li>
  <li>
    <a href="morph.html" title="Next Chapter: Morphing and averaging"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">Morphing and ... &raquo;</span>
    </a>
  </li>
<form action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="col-md-12">
      
  <div class="section" id="the-minimum-norm-current-estimates">
<span id="ch-mne"></span><h1>The minimum-norm current estimates<a class="headerlink" href="#the-minimum-norm-current-estimates" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#overview" id="id4">Overview</a></li>
<li><a class="reference internal" href="#minimum-norm-estimates" id="id5">Minimum-norm estimates</a><ul>
<li><a class="reference internal" href="#the-linear-inverse-operator" id="id6">The linear inverse operator</a></li>
<li><a class="reference internal" href="#regularization" id="id7">Regularization</a></li>
<li><a class="reference internal" href="#whitening-and-scaling" id="id8">Whitening and scaling</a></li>
<li><a class="reference internal" href="#regularization-of-the-noise-covariance-matrix" id="id9">Regularization of the noise-covariance matrix</a></li>
<li><a class="reference internal" href="#computation-of-the-solution" id="id10">Computation of the solution</a></li>
<li><a class="reference internal" href="#noise-normalization" id="id11">Noise normalization</a></li>
<li><a class="reference internal" href="#predicted-data" id="id12">Predicted data</a></li>
<li><a class="reference internal" href="#cortical-patch-statistics" id="id13">Cortical patch statistics</a></li>
<li><a class="reference internal" href="#the-orientation-constraints" id="id14">The orientation constraints</a></li>
<li><a class="reference internal" href="#depth-weighting" id="id15">Depth weighting</a></li>
<li><a class="reference internal" href="#fmri-guided-estimates" id="id16">fMRI-guided estimates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#effective-number-of-averages" id="id17">Effective number of averages</a></li>
<li><a class="reference internal" href="#inverse-operator-decomposition" id="id18">Inverse-operator decomposition</a></li>
<li><a class="reference internal" href="#producing-movies-and-snapshots" id="id19">Producing movies and snapshots</a></li>
<li><a class="reference internal" href="#computing-inverse-from-raw-and-evoked-data" id="id20">Computing inverse from raw and evoked data</a><ul>
<li><a class="reference internal" href="#implementation-details" id="id21">Implementation details</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id4">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>This page describes the mathematical concepts and the
computation of the minimum-norm estimates.
Using the UNIX commands this is accomplished with two programs:
<a class="reference internal" href="../c_reference.html#mne-inverse-operator"><em>mne_inverse_operator</em></a> and <a class="reference internal" href="../c_reference.html#mne-make-movie"><em>mne_make_movie</em></a> or in Python
using <a class="reference internal" href="../../generated/mne.minimum_norm.make_inverse_operator.html#mne.minimum_norm.make_inverse_operator" title="mne.minimum_norm.make_inverse_operator"><tt class="xref py py-func docutils literal"><span class="pre">mne.minimum_norm.make_inverse_operator()</span></tt></a>
and the <tt class="docutils literal"><span class="pre">apply</span></tt> functions. The use of these functions is
presented in the tutorial <a class="reference internal" href="../../auto_tutorials/plot_mne_dspm_source_localization.html#tut-inverse-mne-dspm"><em>Source localization with MNE/dSPM/sLORETA</em></a>.</p>
<p>The page starts with a mathematical description of the method.
The interactive program for inspecting data and inverse solutions,
<a class="reference internal" href="../c_reference.html#mne-analyze"><em>mne_analyze</em></a>, is covered in <a class="reference internal" href="../gui/analyze.html#ch-interactive-analysis"><em>Interactive analysis with mne_analyze</em></a>.</p>
</div>
<div class="section" id="minimum-norm-estimates">
<span id="cbbdjfbj"></span><h2><a class="toc-backref" href="#id5">Minimum-norm estimates</a><a class="headerlink" href="#minimum-norm-estimates" title="Permalink to this headline">¶</a></h2>
<p>This section describes the mathematical details of the calculation
of minimum-norm estimates. In Bayesian sense, the ensuing current
distribution is the maximum a posteriori (MAP) estimate under the
following assumptions:</p>
<ul class="simple">
<li>The viable locations of the currents
are constrained to the cortex. Optionally, the current orientations
can be fixed to be normal to the cortical mantle.</li>
<li>The amplitudes of the currents have a Gaussian prior distribution
with a known source covariance matrix.</li>
<li>The measured data contain additive noise with a Gaussian distribution with
a known covariance matrix. The noise is not correlated over time.</li>
</ul>
<div class="section" id="the-linear-inverse-operator">
<h3><a class="toc-backref" href="#id6">The linear inverse operator</a><a class="headerlink" href="#the-linear-inverse-operator" title="Permalink to this headline">¶</a></h3>
<p>The measured data in the source estimation procedure consists
of MEG and EEG data, recorded on a total of N channels. The task
is to estimate a total of M strengths of sources located on the
cortical mantle. If the number of source locations is P, M = P for
fixed-orientation sources and M = 3P if the source orientations
are unconstrained. The regularized linear inverse operator following
from the Bayesian approach is given by the <span class="math">\(M \times N\)</span> matrix</p>
<div class="math">
\[M = R' G^T (G R' G^T + C)^{-1}\ ,\]</div>
<p>where G is the gain matrix relating the source strengths
to the measured MEG/EEG data, <span class="math">\(C\)</span> is the data noise-covariance matrix
and <span class="math">\(R'\)</span> is the source covariance matrix.
The dimensions of these matrices are <span class="math">\(N \times M\)</span>, <span class="math">\(N \times N\)</span>,
and <span class="math">\(M \times M\)</span>, respectively. The <span class="math">\(M \times 1\)</span> source-strength
vector is obtained by multiplying the <span class="math">\(N \times 1\)</span> data
vector by <span class="math">\(M\)</span>.</p>
<p>The expected value of the current amplitudes at time <em>t</em> is
then given by <span class="math">\(\hat{j}(t) = Mx(t)\)</span>, where <span class="math">\(x(t)\)</span> is
a vector containing the measured MEG and EEG data values at time <em>t</em>.</p>
</div>
<div class="section" id="regularization">
<span id="mne-regularization"></span><h3><a class="toc-backref" href="#id7">Regularization</a><a class="headerlink" href="#regularization" title="Permalink to this headline">¶</a></h3>
<p>The a priori variance of the currents is, in practise, unknown.
We can express this by writing <span class="math">\(R' = R/ \lambda^2\)</span>,
which yields the inverse operator</p>
<div class="math">
\[M = R G^T (G R G^T + \lambda^2 C)^{-1}\ ,\]</div>
<p>where the unknown current amplitude is now interpreted in
terms of the regularization parameter <span class="math">\(\lambda^2\)</span>.
Small <span class="math">\(\lambda^2\)</span> corresponds to large current amplitudes
and complex estimate current patterns while a large <span class="math">\(\lambda^2\)</span> means the
amplitude of the current is limited and a simpler, smooth, current
estimate is obtained.</p>
<p>We can arrive in the regularized linear inverse operator
also by minimizing the cost function</p>
<div class="math">
\[S = \tilde{e}^T \tilde{e} + \lambda^2 j^T R^{-1} j\ ,\]</div>
<p>where the first term consists of the difference between the
whitened measured data (see <a class="reference internal" href="#chddhage"><em>Whitening and scaling</em></a>) and those predicted
by the model while the second term is a weighted-norm of the current
estimate. It is seen that, with increasing <span class="math">\(\lambda^2\)</span>,
the source term receive more weight and larger discrepancy between
the measured and predicted data is tolerable.</p>
</div>
<div class="section" id="whitening-and-scaling">
<span id="chddhage"></span><h3><a class="toc-backref" href="#id8">Whitening and scaling</a><a class="headerlink" href="#whitening-and-scaling" title="Permalink to this headline">¶</a></h3>
<p>The MNE software employs data whitening so that a &#8216;whitened&#8217; inverse operator
assumes the form</p>
<div class="math">
\[\tilde{M} = R \tilde{G}^T (\tilde{G} R \tilde{G}^T + I)^{-1}\ ,\]</div>
<p>where <span class="math">\(\tilde{G} = C^{-^1/_2}G\)</span> is the spatially
whitened gain matrix. The expected current values are <span class="math">\(\hat{j} = Mx(t)\)</span>,
where <span class="math">\(x(t) = C^{-^1/_2}x(t)\)</span> is a the whitened measurement
vector at <em>t</em>. The spatial whitening operator
is obtained with the help of the eigenvalue decomposition <span class="math">\(C = U_C \Lambda_C^2 U_C^T\)</span> as <span class="math">\(C^{-^1/_2} = \Lambda_C^{-1} U_C^T\)</span>.
In the MNE software the noise-covariance matrix is stored as the
one applying to raw data. To reflect the decrease of noise due to
averaging, this matrix, <span class="math">\(C_0\)</span>, is scaled
by the number of averages, <span class="math">\(L\)</span>, <em>i.e.</em>, <span class="math">\(C = C_0 / L\)</span>.</p>
<p>As shown above, regularization of the inverse solution is
equivalent to a change in the variance of the current amplitudes
in the Bayesian <em>a priori</em> distribution.</p>
<p>Convenient choice for the source-covariance matrix <span class="math">\(R\)</span> is
such that <span class="math">\(\text{trace}(\tilde{G} R \tilde{G}^T) / \text{trace}(I) = 1\)</span>. With this choice we
can approximate <span class="math">\(\lambda^2 \sim 1/SNR\)</span>, where SNR is
the (power) signal-to-noise ratio of the whitened data.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The definition of the signal to noise-ratio/ <span class="math">\(\lambda^2\)</span> relationship
given above works nicely for the whitened forward solution. In the
un-whitened case scaling with the trace ratio
<span class="math">\(\text{trace}(GRG^T) / \text{trace}(C)\)</span>
does not make sense, since the diagonal elements summed have, in general,
different units of measure. For example, the MEG data are expressed
in T or T/m whereas the unit of EEG is Volts.</p>
</div>
<p>See <a class="reference internal" href="../../auto_tutorials/plot_compute_covariance.html#tut-compute-covariance"><em>Computing covariance matrix</em></a> for example of noise covariance
computation and whitening.</p>
</div>
<div class="section" id="regularization-of-the-noise-covariance-matrix">
<span id="cov-regularization"></span><h3><a class="toc-backref" href="#id9">Regularization of the noise-covariance matrix</a><a class="headerlink" href="#regularization-of-the-noise-covariance-matrix" title="Permalink to this headline">¶</a></h3>
<p>Since finite amount of data is usually available to compute
an estimate of the noise-covariance matrix <span class="math">\(C\)</span>,
the smallest eigenvalues of its estimate are usually inaccurate
and smaller than the true eigenvalues. Depending on the seriousness
of this problem, the following quantities can be affected:</p>
<ul class="simple">
<li>The model data predicted by the current estimate,</li>
<li>Estimates of signal-to-noise ratios, which lead to estimates
of the required regularization, see <a class="reference internal" href="#mne-regularization"><em>Regularization</em></a>,</li>
<li>The estimated current values, and</li>
<li>The noise-normalized estimates, see <a class="reference internal" href="#noise-normalization"><em>Noise normalization</em></a>.</li>
</ul>
<p>Fortunately, the latter two are least likely to be affected
due to regularization of the estimates. However, in some cases especially
the EEG part of the noise-covariance matrix estimate can be deficient, <em>i.e.</em>,
it may possess very small eigenvalues and thus regularization of
the noise-covariance matrix is advisable.</p>
<p>Historically, the MNE software accomplishes the regularization by replacing
a noise-covariance matrix estimate <span class="math">\(C\)</span> with</p>
<div class="math">
\[C' = C + \sum_k {\varepsilon_k \bar{\sigma_k}^2 I^{(k)}}\ ,\]</div>
<p>where the index <span class="math">\(k\)</span> goes across
the different channel groups (MEG planar gradiometers, MEG axial
gradiometers and magnetometers, and EEG), <span class="math">\(\varepsilon_k\)</span> are
the corresponding regularization factors, <span class="math">\(\bar{\sigma_k}\)</span> are
the average variances across the channel groups, and <span class="math">\(I^{(k)}\)</span> are
diagonal matrices containing ones at the positions corresponding
to the channels contained in each channel group.</p>
<p>Using the UNIX tools <a class="reference internal" href="../c_reference.html#mne-inverse-operator"><em>mne_inverse_operator</em></a>, the values
<span class="math">\(\varepsilon_k\)</span> can be adjusted with the regularization options
<tt class="docutils literal"><span class="pre">--magreg</span></tt> , <tt class="docutils literal"><span class="pre">--gradreg</span></tt> , and <tt class="docutils literal"><span class="pre">--eegreg</span></tt> specified at the time of the
inverse operator decomposition, see <a class="reference internal" href="#inverse-operator"><em>Inverse-operator decomposition</em></a>. The convenience script
<em class="xref std std-ref">mne_do_inverse_solution</em> has the <tt class="docutils literal"><span class="pre">--magreg</span></tt> and <tt class="docutils literal"><span class="pre">--gradreg</span></tt> combined to
a single option, <tt class="docutils literal"><span class="pre">--megreg</span></tt> , see <a class="reference internal" href="../cookbook.html#cihcfjei"><em>Calculating the inverse operator</em></a>.
Suggested range of values for <span class="math">\(\varepsilon_k\)</span> is <span class="math">\(0.05 \dotso 0.2\)</span>.</p>
</div>
<div class="section" id="computation-of-the-solution">
<span id="mne-solution"></span><h3><a class="toc-backref" href="#id10">Computation of the solution</a><a class="headerlink" href="#computation-of-the-solution" title="Permalink to this headline">¶</a></h3>
<p>The most straightforward approach to calculate the MNE is
to employ expression for the original or whitened inverse operator
directly. However, for computational convenience we prefer to take
another route, which employs the singular-value decomposition (SVD)
of the matrix</p>
<div class="math">
\[A = \tilde{G} R^{^1/_2} = U \Lambda V^T\]</div>
<p>where the superscript <span class="math">\(^1/_2\)</span> indicates a
square root of <span class="math">\(R\)</span>. For a diagonal matrix,
one simply takes the square root of <span class="math">\(R\)</span> while
in the more general case one can use the Cholesky factorization <span class="math">\(R = R_C R_C^T\)</span> and
thus <span class="math">\(R^{^1/_2} = R_C\)</span>.</p>
<p>With the above SVD it is easy to show that</p>
<div class="math">
\[\tilde{M} = R^{^1/_2} V \Gamma U^T\]</div>
<p>where the elements of the diagonal matrix <span class="math">\(\Gamma\)</span> are</p>
<div class="math">
\[\gamma_k = \frac{1}{\lambda_k} \frac{\lambda_k^2}{\lambda_k^2 + \lambda^2}\ .\]</div>
<p>With <span class="math">\(w(t) = U^T C^{-^1/_2} x(t)\)</span> the expression for
the expected current is</p>
<div class="math">
\[\hat{j}(t) = R^C V \Gamma w(t) = \sum_k {\bar{v_k} \gamma_k w_k(t)}\ ,\]</div>
<p>where <span class="math">\(\bar{v_k} = R^C v_k\)</span>, <span class="math">\(v_k\)</span> being
the <span class="math">\(k\)</span> th column of <span class="math">\(V\)</span>. It is thus seen that the current estimate is
a weighted sum of the &#8216;modified&#8217; eigenleads <span class="math">\(v_k\)</span>.</p>
<p>It is easy to see that <span class="math">\(w(t) \propto \sqrt{L}\)</span>.
To maintain the relation <span class="math">\((\tilde{G} R \tilde{G}^T) / \text{trace}(I) = 1\)</span> when <span class="math">\(L\)</span> changes
we must have <span class="math">\(R \propto 1/L\)</span>. With this approach, <span class="math">\(\lambda_k\)</span> is
independent of  <span class="math">\(L\)</span> and, for fixed <span class="math">\(\lambda\)</span>,
we see directly that <span class="math">\(j(t)\)</span> is independent
of <span class="math">\(L\)</span>.</p>
</div>
<div class="section" id="noise-normalization">
<span id="id1"></span><h3><a class="toc-backref" href="#id11">Noise normalization</a><a class="headerlink" href="#noise-normalization" title="Permalink to this headline">¶</a></h3>
<p>The noise-normalized linear estimates introduced by Dale
et al. require division of the expected current amplitude by its
variance. Noise normalization serves three purposes:</p>
<ul class="simple">
<li>It converts the expected current value
into a dimensionless statistical test variable. Thus the resulting
time and location dependent values are often referred to as dynamic
statistical parameter maps (dSPM).</li>
<li>It reduces the location bias of the estimates. In particular,
the tendency of the MNE to prefer superficial currents is eliminated.</li>
<li>The width of the point-spread function becomes less dependent
on the source location on the cortical mantle. The point-spread
is defined as the MNE resulting from the signals coming from a point
current source (a current dipole) located at a certain point on
the cortex.</li>
</ul>
<p>In practice, noise normalization requires the computation
of the diagonal elements of the matrix</p>
<div class="math">
\[M C M^T = \tilde{M} \tilde{M}^T\ .\]</div>
<p>With help of the singular-value decomposition approach we
see directly that</p>
<div class="math">
\[\tilde{M} \tilde{M}^T\ = \bar{V} \Gamma^2 \bar{V}^T\ .\]</div>
<p>Under the conditions expressed at the end of <a class="reference internal" href="#mne-solution"><em>Computation of the solution</em></a>, it follows that the <em>t</em>-statistic values associated
with fixed-orientation sources) are thus proportional to <span class="math">\(\sqrt{L}\)</span> while
the <em>F</em>-statistic employed with free-orientation sources is proportional
to <span class="math">\(L\)</span>, correspondingly.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A section discussing statistical considerations    related to the noise normalization procedure will be added to this    manual in one of the subsequent releases.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The MNE software usually computes the square    roots of the F-statistic to be displayed on the inflated cortical    surfaces. These are also proportional to <span class="math">\(\sqrt{L}\)</span>.</p>
</div>
</div>
<div class="section" id="predicted-data">
<span id="chdcacdc"></span><h3><a class="toc-backref" href="#id12">Predicted data</a><a class="headerlink" href="#predicted-data" title="Permalink to this headline">¶</a></h3>
<p>Under noiseless conditions the SNR is infinite and thus leads
to <span class="math">\(\lambda^2 = 0\)</span> and the minimum-norm estimate
explains the measured data perfectly. Under realistic conditions,
however, <span class="math">\(\lambda^2 &gt; 0\)</span> and there is a misfit
between measured data and those predicted by the MNE. Comparison
of the predicted data, here denoted by <span class="math">\(x(t)\)</span>,
and measured one can give valuable insight on the correctness of
the regularization applied.</p>
<p>In the SVD approach we easily find</p>
<div class="math">
\[\hat{x}(t) = G \hat{j}(t) = C^{^1/_2} U \Pi w(t)\ ,\]</div>
<p>where the diagonal matrix <span class="math">\(\Pi\)</span> has
elements <span class="math">\(\pi_k = \lambda_k \gamma_k\)</span> The predicted data is
thus expressed as the weighted sum of the &#8216;recolored eigenfields&#8217; in <span class="math">\(C^{^1/_2} U\)</span>.</p>
</div>
<div class="section" id="cortical-patch-statistics">
<span id="patch-stats"></span><h3><a class="toc-backref" href="#id13">Cortical patch statistics</a><a class="headerlink" href="#cortical-patch-statistics" title="Permalink to this headline">¶</a></h3>
<p>If the <tt class="docutils literal"><span class="pre">--cps</span></tt> option was used in source space
creation (see <a class="reference internal" href="../cookbook.html#setting-up-source-space"><em>Setting up the source space</em></a>) or if mne_add_patch_info described
in <a class="reference internal" href="../c_reference.html#mne-add-patch-info"><em>mne_add_patch_info</em></a> was run manually the source space file
will contain for each vertex of the cortical surface the information
about the source space point closest to it as well as the distance
from the vertex to this source space point. The vertices for which
a given source space point is the nearest one define the cortical
patch associated with with the source space point. Once these data
are available, it is straightforward to compute the following cortical
patch statistics (CPS) for each source location <span class="math">\(d\)</span>:</p>
<ul class="simple">
<li>The average over the normals of at the
vertices in a patch, <span class="math">\(\bar{n_d}\)</span>,</li>
<li>The areas of the patches, <span class="math">\(A_d\)</span>,
and</li>
<li>The average deviation of the vertex normals in a patch from
their average, <span class="math">\(\sigma_d\)</span>, given in degrees.</li>
</ul>
</div>
<div class="section" id="the-orientation-constraints">
<h3><a class="toc-backref" href="#id14">The orientation constraints</a><a class="headerlink" href="#the-orientation-constraints" title="Permalink to this headline">¶</a></h3>
<p>The principal sources of MEG and EEG signals are generally
believed to be postsynaptic currents in the cortical pyramidal neurons.
Since the net primary current associated with these microscopic
events is oriented normal to the cortical mantle, it is reasonable
to use the cortical normal orientation as a constraint in source
estimation. In addition to allowing completely free source orientations,
the MNE software implements three orientation constraints based
of the surface normal data:</p>
<ul class="simple">
<li>Source orientation can be rigidly fixed
to the surface normal direction (the <tt class="docutils literal"><span class="pre">--fixed</span></tt> option).
If cortical patch statistics are available the average normal over
each patch, <span class="math">\(\bar{n_d}\)</span>, are used to define
the source orientation. Otherwise, the vertex normal at the source
space location is employed.</li>
<li>A <em>location independent or fixed loose orientation
constraint</em> (fLOC) can be employed (the <tt class="docutils literal"><span class="pre">--loose</span></tt> option).
In this approach, a source coordinate system based on the local
surface orientation at the source location is employed. By default,
the three columns of the gain matrix G, associated with a given
source location, are the fields of unit dipoles pointing to the
directions of the x, y, and z axis of the coordinate system employed
in the forward calculation (usually the MEG head coordinate frame).
For LOC the orientation is changed so that the first two source
components lie in the plane normal to the surface normal at the source
location and the third component is aligned with it. Thereafter, the
variance of the source components tangential to the cortical surface are
reduced by a factor defined by the <tt class="docutils literal"><span class="pre">--loose</span></tt> option.</li>
<li>A <em>variable loose orientation constraint</em> (vLOC)
can be employed (the <tt class="docutils literal"><span class="pre">--loosevar</span></tt> option). This is similar
to fLOC except that the value given with the <tt class="docutils literal"><span class="pre">--loosevar</span></tt> option
will be multiplied by <span class="math">\(\sigma_d\)</span>, defined above.</li>
</ul>
</div>
<div class="section" id="depth-weighting">
<span id="id2"></span><h3><a class="toc-backref" href="#id15">Depth weighting</a><a class="headerlink" href="#depth-weighting" title="Permalink to this headline">¶</a></h3>
<p>The minimum-norm estimates have a bias towards superficial
currents. This tendency can be alleviated by adjusting the source
covariance matrix <span class="math">\(R\)</span> to favor deeper source locations. In the depth
weighting scheme employed in MNE analyze, the elements of <span class="math">\(R\)</span> corresponding
to the <span class="math">\(p\)</span> th source location are be
scaled by a factor</p>
<div class="math">
\[f_p = (g_{1p}^T g_{1p} + g_{2p}^T g_{2p} + g_{3p}^T g_{3p})^{-\gamma}\ ,\]</div>
<p>where <span class="math">\(g_{1p}\)</span>, <span class="math">\(g_{2p}\)</span>, and <span class="math">\(g_{3p}\)</span> are the three columns
of <span class="math">\(G\)</span> corresponding to source location <span class="math">\(p\)</span> and <span class="math">\(\gamma\)</span> is
the order of the depth weighting, specified with the <tt class="docutils literal"><span class="pre">--weightexp</span></tt> option
to mne_inverse_operator . The
maximal amount of depth weighting can be adjusted <tt class="docutils literal"><span class="pre">--weightlimit</span></tt> option.</p>
</div>
<div class="section" id="fmri-guided-estimates">
<span id="mne-fmri-estimates"></span><h3><a class="toc-backref" href="#id16">fMRI-guided estimates</a><a class="headerlink" href="#fmri-guided-estimates" title="Permalink to this headline">¶</a></h3>
<p>The fMRI weighting in MNE software means that the source-covariance matrix
is modified to favor areas of significant fMRI activation. For this purpose,
the fMRI activation map is thresholded first at the value defined by
the <tt class="docutils literal"><span class="pre">--fmrithresh</span></tt> option to mne_do_inverse_operator or mne_inverse_operator .
Thereafter, the source-covariance matrix values corresponding to
the the sites under the threshold are multiplied by <span class="math">\(f_{off}\)</span>, set
by the <tt class="docutils literal"><span class="pre">--fmrioff</span></tt> option.</p>
<p>It turns out that the fMRI weighting has a strong influence
on the MNE but the noise-normalized estimates are much less affected
by it.</p>
</div>
</div>
<div class="section" id="effective-number-of-averages">
<span id="cbbdgiae"></span><h2><a class="toc-backref" href="#id17">Effective number of averages</a><a class="headerlink" href="#effective-number-of-averages" title="Permalink to this headline">¶</a></h2>
<p>It is often the case that the epoch to be analyzed is a linear
combination over conditions rather than one of the original averages
computed. As stated above, the noise-covariance matrix computed
is originally one corresponding to raw data. Therefore, it has to
be scaled correctly to correspond to the actual or effective number
of epochs in the condition to be analyzed. In general, we have</p>
<div class="math">
\[C = C_0 / L_{eff}\]</div>
<p>where <span class="math">\(L_{eff}\)</span> is the effective
number of averages. To calculate <span class="math">\(L_{eff}\)</span> for
an arbitrary linear combination of conditions</p>
<div class="math">
\[y(t) = \sum_{i = 1}^n {w_i x_i(t)}\]</div>
<p>we make use of the the fact that the noise-covariance matrix</p>
<div class="math">
\[C_y = \sum_{i = 1}^n {w_i^2 C_{x_i}} = C_0 \sum_{i = 1}^n {w_i^2 / L_i}\]</div>
<p>which leads to</p>
<div class="math">
\[1 / L_{eff} = \sum_{i = 1}^n {w_i^2 / L_i}\]</div>
<p>An important special case  of the above is a weighted average,
where</p>
<div class="math">
\[w_i = L_i / \sum_{i = 1}^n {L_i}\]</div>
<p>and, therefore</p>
<div class="math">
\[L_{eff} = \sum_{i = 1}^n {L_i}\]</div>
<p>Instead of a weighted average, one often computes a weighted
sum, a simplest case being a difference or sum of two categories.
For a difference <span class="math">\(w_1 = 1\)</span> and <span class="math">\(w_2 = -1\)</span> and
thus</p>
<div class="math">
\[1 / L_{eff} = 1 / L_1 + 1 / L_2\]</div>
<p>or</p>
<div class="math">
\[L_{eff} = \frac{L_1 L_2}{L_1 + L_2}\]</div>
<p>Interestingly, the same holds for a sum, where <span class="math">\(w_1 = w_2 = 1\)</span>.
Generalizing, for any combination of sums and differences, where <span class="math">\(w_i = 1\)</span> or <span class="math">\(w_i = -1\)</span>, <span class="math">\(i = 1 \dotso n\)</span>,
we have</p>
<div class="math">
\[1 / L_{eff} = \sum_{i = 1}^n {1/{L_i}}\]</div>
</div>
<div class="section" id="inverse-operator-decomposition">
<span id="inverse-operator"></span><h2><a class="toc-backref" href="#id18">Inverse-operator decomposition</a><a class="headerlink" href="#inverse-operator-decomposition" title="Permalink to this headline">¶</a></h2>
<p>The program <a class="reference internal" href="../c_reference.html#mne-inverse-operator"><em>mne_inverse_operator</em></a> calculates
the decomposition <span class="math">\(A = \tilde{G} R^C = U \Lambda \bar{V^T}\)</span>,
described in <a class="reference internal" href="#mne-solution"><em>Computation of the solution</em></a>. It is normally invoked from the convenience
script <a class="reference internal" href="../c_reference.html#mne-do-inverse-operator"><em>mne_do_inverse_operator</em></a>.</p>
</div>
<div class="section" id="producing-movies-and-snapshots">
<span id="movies-and-snapshots"></span><h2><a class="toc-backref" href="#id19">Producing movies and snapshots</a><a class="headerlink" href="#producing-movies-and-snapshots" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="../c_reference.html#mne-make-movie"><em>mne_make_movie</em></a> is a program
for producing movies and snapshot graphics frames without any graphics
output to the screen. In addition, <a class="reference internal" href="../c_reference.html#mne-make-movie"><em>mne_make_movie</em></a> can
produce stc or w files which contain the numerical current estimate
data in a simple binary format for postprocessing. These files can
be displayed in <a class="reference internal" href="../c_reference.html#mne-analyze"><em>mne_analyze</em></a>,
see <a class="reference internal" href="../gui/analyze.html#ch-interactive-analysis"><em>Interactive analysis with mne_analyze</em></a>, utilized in the cross-subject averaging
process, see <a class="reference internal" href="morph.html#ch-morph"><em>Morphing and averaging</em></a>, and read into Matlab using the MNE
Matlab toolbox, see <a class="reference internal" href="../matlab.html#ch-matlab"><em>Matlab toolbox</em></a>.</p>
</div>
<div class="section" id="computing-inverse-from-raw-and-evoked-data">
<span id="computing-inverse"></span><h2><a class="toc-backref" href="#id20">Computing inverse from raw and evoked data</a><a class="headerlink" href="#computing-inverse-from-raw-and-evoked-data" title="Permalink to this headline">¶</a></h2>
<p>The purpose of the utility <a class="reference internal" href="../c_reference.html#mne-compute-raw-inverse"><em>mne_compute_raw_inverse</em></a> is
to compute inverse solutions from either evoked-response or raw
data at specified ROIs (labels) and to save the results in a fif
file which can be viewed with <a class="reference internal" href="../c_reference.html#mne-browse-raw"><em>mne_browse_raw</em></a>,
read to Matlab directly using the MNE Matlab Toolbox, see <a class="reference internal" href="../matlab.html#ch-matlab"><em>Matlab toolbox</em></a>,
or converted to Matlab format using either <a class="reference internal" href="../c_reference.html#mne-convert-mne-data"><em>mne_convert_mne_data</em></a>,
<a class="reference internal" href="../c_reference.html#mne-raw2mat"><em>mne_raw2mat</em></a>, or <a class="reference internal" href="../c_reference.html#mne-epochs2mat"><em>mne_epochs2mat</em></a>. See
<a class="reference internal" href="../c_reference.html#mne-compute-raw-inverse"><em>mne_compute_raw_inverse</em></a> for command-line options.</p>
<div class="section" id="implementation-details">
<span id="id3"></span><h3><a class="toc-backref" href="#id21">Implementation details</a><a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h3>
<p>The fif files output from mne_compute_raw_inverse have
various fields of the channel information set to facilitate interpretation
by postprocessing software as follows:</p>
<p><strong>channel name</strong></p>
<blockquote>
<div>Will be set to J[xyz] &lt;<em>number</em>&gt; ,
where the source component is indicated by the coordinat axis name
and number is the vertex number, starting from zero, in the complete
triangulation of the hemisphere in question.</div></blockquote>
<p><strong>logical channel number</strong></p>
<blockquote>
<div>Will be set to is the vertex number, starting from zero, in the
complete triangulation of the hemisphere in question.</div></blockquote>
<p><strong>sensor location</strong></p>
<blockquote>
<div>The location of the vertex in head coordinates or in MRI coordinates,
determined by the <tt class="docutils literal"><span class="pre">--mricoord</span></tt> flag.</div></blockquote>
<p><strong>sensor orientation</strong></p>
<blockquote>
<div>The <em>x</em>-direction unit vector will point to the
direction of the current. Other unit vectors are set to zero. Again,
the coordinate system in which the orientation is expressed depends
on the <tt class="docutils literal"><span class="pre">--mricoord</span></tt> flag.</div></blockquote>
<p>The <tt class="docutils literal"><span class="pre">--align_z</span></tt> flag tries to align the signs
of the signals at different vertices of the label. For this purpose,
the surface normals within the label are collected into a <span class="math">\(n_{vert} \times 3\)</span> matrix.
The preferred orientation will be taken as the first right singular
vector of this matrix, corresponding to its largest singular value.
If the dot product of the surface normal of a vertex is negative,
the sign of the estimates at this vertex are inverted. The inversion
is reflected in the current direction vector listed in the channel
information, see above.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The raw data files output by <a class="reference internal" href="../c_reference.html#mne-compute-raw-inverse"><em>mne_compute_raw_inverse</em></a> can be converted to mat files with <a class="reference internal" href="../c_reference.html#mne-raw2mat"><em>mne_raw2mat</em></a>. Alternatively, the files can be read directly from Matlab using the routines in the MNE Matlab toolbox, see <a class="reference internal" href="../matlab.html#ch-matlab"><em>Matlab toolbox</em></a>. The evoked data output can be easily read directly from Matlab using the fiff_load_evoked routine in the MNE Matlab toolbox. Both raw data and evoked output files can be loaded into <a class="reference internal" href="../c_reference.html#mne-browse-raw"><em>mne_browse_raw</em></a>, see <a class="reference internal" href="../gui/browse.html#ch-browse"><em>Browsing raw data with mne_browse_raw</em></a>.</p>
</div>
</div>
</div>
</div>


    </div>
    
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2012-2016, MNE Developers. Last updated on 2016-05-11.<br/>
    </p>
  </div>
</footer>
  </body>
</html>